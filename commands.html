<html>
<head>
	<title>HM4 - command reference</title>

	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css.map" crossorigin="anonymous" />
	<!-- link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css"    crossorigin="anonymous" / -->

	<style><!--
	pre {
		border:		dashed 1px black;
		padding:	10px;
	}

	pre i {
		color:		#A00;
	}

	a {
		font-weight:	bold;
		text-decoration: none;
		color:		#007;
	}

	div.cmd {
		margin-top:	30px;
		margin-bottom:	30px;
	}

	div.cmd h2 {
		--border-top:	solid 1px black;
		border-bottom:	solid 1px black;

		--background-color: #aaa;
		padding-top:	30px;
		padding-bottom:	10px;
	}

	div.cmd p.top {
		border-top:	solid 1px black;
		padding-top:	10px;
		padding-bottom:	10px;
	}

	div.cmd > i {
		background-color: #ddd;
		padding-left:	10px;
		padding-right:	10px;
		font-style:	normal;
		font-weight:	bold;
		border:		dotted 1px black;
	}

	div.cmd table,
	table.x {
		border:		solid 3px black;
		border-collapse: collapse;
	}

	div.cmd table td {
		padding:	10px;
	}

	div.menurow {
		display:	flex;
		flex-wrap:	wrap;
	}

	div.menurow div {
		flex:		200px;

		border:		dotted 1px #007;

		margin:		3px;
		padding:	10px;

		vertical-align:	top;
	}

	--></style>
</head>
<body>

<a target="#top"></a>

<h1>HM4 - command reference</h1>

<h2>List of commands</h2>


<div class="menurow">
			<div>
			<b>immutable.h</b><br />
			&nbsp;

					<li><a href="#GET">GET</a></li>
				<li><a href="#MGET">MGET</a></li>
				<li><a href="#EXISTS">EXISTS</a></li>
				<li><a href="#TTL">TTL</a></li>
				<li><a href="#EXPIRETIME">EXPIRETIME</a></li>
				<li><a href="#DUMP">DUMP</a></li>
				<li><a href="#GETRANGE">GETRANGE</a></li>
				<li><a href="#STRLEN">STRLEN</a></li>
				</div>
			<div>
			<b>immutable_x.h</b><br />
			&nbsp;

					<li><a href="#XNGET">XNGET</a></li>
				<li><a href="#XRGET">XRGET</a></li>
				<li><a href="#XUGET">XUGET</a></li>
				<li><a href="#XNGETKEYS">XNGETKEYS</a></li>
				<li><a href="#XRGETKEYS">XRGETKEYS</a></li>
				<li><a href="#XUGETKEYS">XUGETKEYS</a></li>
				</div>
			<div>
			<b>accumulators_x.h</b><br />
			&nbsp;

					<li><a href="#COUNT">COUNT</a></li>
				<li><a href="#SUM">SUM</a></li>
				<li><a href="#XNCOUNT">XNCOUNT</a></li>
				<li><a href="#XRCOUNT">XRCOUNT</a></li>
				<li><a href="#XNSUM">XNSUM</a></li>
				<li><a href="#XRSUM">XRSUM</a></li>
				<li><a href="#XNMIN">XNMIN</a></li>
				<li><a href="#XRMIN">XRMIN</a></li>
				<li><a href="#XNMAX">XNMAX</a></li>
				<li><a href="#XRMAX">XRMAX</a></li>
				<li><a href="#XNFIRST">XNFIRST</a></li>
				<li><a href="#XRFIRST">XRFIRST</a></li>
				<li><a href="#XNLAST">XNLAST</a></li>
				<li><a href="#XRLAST">XRLAST</a></li>
				<li><a href="#XNAVG">XNAVG</a></li>
				<li><a href="#XRAVG">XRAVG</a></li>
				</div>
			<div>
			<b>mutable.h</b><br />
			&nbsp;

					<li><a href="#SET">SET</a></li>
				<li><a href="#MSET">MSET</a></li>
				<li><a href="#MSETNX">MSETNX</a></li>
				<li><a href="#MSETXX">MSETXX</a></li>
				<li><a href="#SETEX">SETEX</a></li>
				<li><a href="#SETNX">SETNX</a></li>
				<li><a href="#SETXX">SETXX</a></li>
				<li><a href="#APPEND">APPEND</a></li>
				<li><a href="#EXPIRE">EXPIRE</a></li>
				<li><a href="#EXPIREAT">EXPIREAT</a></li>
				<li><a href="#PERSIST">PERSIST</a></li>
				<li><a href="#PERSISTDELETED">PERSISTDELETED</a></li>
				<li><a href="#DEL">DEL</a></li>
				</div>
			<div>
			<b>mutable_get.h</b><br />
			&nbsp;

					<li><a href="#GETSET">GETSET</a></li>
				<li><a href="#GETDEL">GETDEL</a></li>
				<li><a href="#GETEX">GETEX</a></li>
				<li><a href="#GETEXAT">GETEXAT</a></li>
				<li><a href="#GETPERSIST">GETPERSIST</a></li>
				</div>
			<div>
			<b>mutable_x.h</b><br />
			&nbsp;

					<li><a href="#XNDEL">XNDEL</a></li>
				<li><a href="#XRDEL">XRDEL</a></li>
				<li><a href="#XNPERSIST">XNPERSIST</a></li>
				<li><a href="#XRPERSIST">XRPERSIST</a></li>
				<li><a href="#XNEXPIRE">XNEXPIRE</a></li>
				<li><a href="#XREXPIRE">XREXPIRE</a></li>
				<li><a href="#XNEXPIREAT">XNEXPIREAT</a></li>
				<li><a href="#XREXPIREAT">XREXPIREAT</a></li>
				</div>
			<div>
			<b>cas.h</b><br />
			&nbsp;

					<li><a href="#CAS">CAS</a></li>
				<li><a href="#CAD">CAD</a></li>
				</div>
			<div>
			<b>copy.h</b><br />
			&nbsp;

					<li><a href="#COPY">COPY</a></li>
				<li><a href="#COPYNX">COPYNX</a></li>
				<li><a href="#RENAME">RENAME</a></li>
				<li><a href="#RENAMENX">RENAMENX</a></li>
				</div>
			<div>
			<b>counter.h</b><br />
			&nbsp;

					<li><a href="#INCR">INCR</a></li>
				<li><a href="#DECR">DECR</a></li>
				<li><a href="#INCRTO">INCRTO</a></li>
				<li><a href="#DECRTO">DECRTO</a></li>
				</div>
			<div>
			<b>(collection module) hash.h</b><br />
			&nbsp;

					<li><a href="#HGETALL">HGETALL</a></li>
				<li><a href="#HGETKEYS">HGETKEYS</a></li>
				<li><a href="#HGETVALS">HGETVALS</a></li>
				<li><a href="#HLEN">HLEN</a></li>
				<li><a href="#HGET">HGET</a></li>
				<li><a href="#HMGET">HMGET</a></li>
				<li><a href="#HEXISTS">HEXISTS</a></li>
				<li><a href="#HSET">HSET</a></li>
				<li><a href="#HMSET">HMSET</a></li>
				<li><a href="#HDEL">HDEL</a></li>
				<li><a href="#HDELALL">HDELALL</a></li>
				<li><a href="#HPERSISTALL">HPERSISTALL</a></li>
				<li><a href="#HEXPIREALL">HEXPIREALL</a></li>
				<li><a href="#HEXPIREATALL">HEXPIREATALL</a></li>
				</div>
			<div>
			<b>queue.h</b><br />
			&nbsp;

					<li><a href="#SADD">SADD</a></li>
				<li><a href="#SPOP">SPOP</a></li>
				</div>
			<div>
			<b>bitset.h</b><br />
			&nbsp;

					<li><a href="#BITSET">BITSET</a></li>
				<li><a href="#BITGET">BITGET</a></li>
				<li><a href="#BITMGET">BITMGET</a></li>
				<li><a href="#BITCOUNT">BITCOUNT</a></li>
				<li><a href="#BITMAX">BITMAX</a></li>
				</div>
			<div>
			<b>geo.h</b><br />
			&nbsp;

					<li><a href="#GEOGET">GEOGET</a></li>
				<li><a href="#GEOMGET">GEOMGET</a></li>
				<li><a href="#GEOADD">GEOADD</a></li>
				<li><a href="#GEOREM">GEOREM</a></li>
				<li><a href="#GEORADIUS">GEORADIUS</a></li>
				<li><a href="#GEODIST">GEODIST</a></li>
				<li><a href="#GEOENCODE">GEOENCODE</a></li>
				<li><a href="#GEODECODE">GEODECODE</a></li>
				</div>
			<div>
			<b>hll.h</b><br />
			&nbsp;

					<li><a href="#PFADD">PFADD</a></li>
				<li><a href="#PFRESERVE">PFRESERVE</a></li>
				<li><a href="#PFCOUNT">PFCOUNT</a></li>
				<li><a href="#PFINTERSECT">PFINTERSECT</a></li>
				<li><a href="#PFMERGE">PFMERGE</a></li>
				<li><a href="#PFBITS">PFBITS</a></li>
				<li><a href="#PFERROR">PFERROR</a></li>
				</div>
			<div>
			<b>bf.h</b><br />
			&nbsp;

					<li><a href="#BFADD">BFADD</a></li>
				<li><a href="#BFRESERVE">BFRESERVE</a></li>
				<li><a href="#BFEXISTS">BFEXISTS</a></li>
				<li><a href="#BFMEXISTS">BFMEXISTS</a></li>
				</div>
			<div>
			<b>cms.h</b><br />
			&nbsp;

					<li><a href="#CMSADD">CMSADD</a></li>
				<li><a href="#CMSRESERVE">CMSRESERVE</a></li>
				<li><a href="#CMSCOUNT">CMSCOUNT</a></li>
				<li><a href="#CMSMCOUNT">CMSMCOUNT</a></li>
				</div>
			<div>
			<b>mortoncurve.h</b><br />
			&nbsp;

					<li><a href="#MC2GET">MC2GET</a></li>
				<li><a href="#MC2MGET">MC2MGET</a></li>
				<li><a href="#MC2EXISTS">MC2EXISTS</a></li>
				<li><a href="#MC2SCORE">MC2SCORE</a></li>
				<li><a href="#MC2ADD">MC2ADD</a></li>
				<li><a href="#MC2REM">MC2REM</a></li>
				<li><a href="#MC2POINT">MC2POINT</a></li>
				<li><a href="#MC2RANGE">MC2RANGE</a></li>
				<li><a href="#MC2RANGENAIVE">MC2RANGENAIVE</a></li>
				<li><a href="#MC2ENCODE">MC2ENCODE</a></li>
				<li><a href="#MC2DECODE">MC2DECODE</a></li>
				</div>
			<div>
			<b>murmur.h</b><br />
			&nbsp;

					<li><a href="#MURMUR">MURMUR</a></li>
				</div>
			<div>
			<b>info.h</b><br />
			&nbsp;

					<li><a href="#INFO">INFO</a></li>
				<li><a href="#DBSIZE">DBSIZE</a></li>
				<li><a href="#DBSIZEMUTABLE">DBSIZEMUTABLE</a></li>
				<li><a href="#VERSION">VERSION</a></li>
				<li><a href="#MAXKEYSIZE">MAXKEYSIZE</a></li>
				<li><a href="#MAXVALSIZE">MAXVALSIZE</a></li>
				<li><a href="#PING">PING</a></li>
				<li><a href="#ECHO">ECHO</a></li>
				<li><a href="#TIME">TIME</a></li>
				</div>
			<div>
			<b>reload.h</b><br />
			&nbsp;

					<li><a href="#LISTMAINTAINANCE">LISTMAINTAINANCE</a></li>
				<li><a href="#SAVE">SAVE</a></li>
				<li><a href="#RELOAD">RELOAD</a></li>
				</div>
			<div>
			<b>compat.h</b><br />
			&nbsp;

					<li><a href="#SELECT">SELECT</a></li>
				<li><a href="#RESET">RESET</a></li>
				<li><a href="#TYPE">TYPE</a></li>
				<li><a href="#TOUCH">TOUCH</a></li>
				</div>
			<div>
			<b>system.h</b><br />
			&nbsp;

					<li><a href="#EXIT">EXIT</a></li>
				<li><a href="#SHUTDOWN">SHUTDOWN</a></li>
				</div>
			<div>
			<b>test.h</b><br />
			&nbsp;

					<li><a href="#TEST">TEST</a></li>
				</div>
	</div>



		<div class="cmd" id="GET">

			<h2>GET key</h2>

			<table border="1">
				<tr><td>Command			</td><td>GET</td></tr>
				<tr><td>Available since		</td><td>1.0.0</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>immutable.h</td></tr>
			</table>

			<h3>Description:</h3>
			Get value of the <i>key</i>. Exact match.
			<h3>Return type:</h3>
			string
			<h3>Return value:</h3>
			Value of the key or empty string.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="MGET">

			<h2>MGET key [key]...</h2>

			<table border="1">
				<tr><td>Command			</td><td>MGET</td></tr>
				<tr><td>Available since		</td><td>1.0.0</td></tr>
				<tr><td>Data lookup complexity	</td><td>[number of keys] * READ</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>immutable.h</td></tr>
			</table>

			<h3>Description:</h3>
			Get value of the <i>key</i>. Exact match.<br />Same as GET but array responce.
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			Value of the key or empty string.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="EXISTS">

			<h2>EXISTS key</h2>

			<table border="1">
				<tr><td>Command			</td><td>EXISTS</td></tr>
				<tr><td>Available since		</td><td>1.2.16</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>immutable.h</td></tr>
			</table>

			<h3>Description:</h3>
			Get information if <i>key</i> exists. Exact match.<br />Operation is not recommended, because it is as fast as if you get the <i>key</i> itself.
			<h3>Return type:</h3>
			bool
			<h3>Return value:</h3>
			0 if the key value pair do not exists.<br />1 if the key value pair exists.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="TTL">

			<h2>TTL key</h2>

			<table border="1">
				<tr><td>Command			</td><td>TTL</td></tr>
				<tr><td>Available since		</td><td>1.2.11</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>immutable.h</td></tr>
			</table>

			<h3>Description:</h3>
			Get TTL value of the <i>key</i>. Exact match.
			<h3>Return type:</h3>
			int
			<h3>Return value:</h3>
			Value of the TTL or 0, if there is no expiration set.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="EXPIRETIME">

			<h2>EXPIRETIME key</h2>

			<table border="1">
				<tr><td>Command			</td><td>EXPIRETIME</td></tr>
				<tr><td>Available since		</td><td>1.2.11</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>immutable.h</td></tr>
			</table>

			<h3>Description:</h3>
			Get timestamp when  <i>key</i> will expire. Exact match.
			<h3>Return type:</h3>
			int
			<h3>Return value:</h3>
			Timestamp or 0, if there is no expiration set.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="DUMP">

			<h2>DUMP key</h2>

			<table border="1">
				<tr><td>Command			</td><td>DUMP</td></tr>
				<tr><td>Available since		</td><td>1.3.4</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>immutable.h</td></tr>
			</table>

			<h3>Description:</h3>
			Get internal <i>key</i> representation. Exact match.<br />Works on deleted and expired keys too.<br />Not compatible with Redis
			<h3>Return type:</h3>
			string
			<h3>Return value:</h3>
			internal <i>key</i> representation
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="GETRANGE">

			<h2>GETRANGE key index_start index_finish</h2>

			<table border="1">
				<tr><td>Command			</td><td>GETRANGE</td></tr>
				<tr><td>Available since		</td><td>1.2.30</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>immutable.h</td></tr>
			</table>

			<h3>Description:</h3>
			Get substring of the value of the <i>key</i> from <i>index_start</i> to <i>index_finish</i>. Exact match.<br />Unlike Redis, negative indexes are not supported.
			<h3>Return type:</h3>
			string
			<h3>Return value:</h3>
			substring of the value or empty string.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="STRLEN">

			<h2>STRLEN / SIZE key</h2>

			<table border="1">
				<tr><td>Command			</td><td>STRLEN</td></tr>
				<tr><td>Available since		</td><td>1.2.17</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>immutable.h</td></tr>
			</table>

			<h3>Description:</h3>
			Get size of the value of the <i>key</i>. Exact match.<br />Useful for debuging HLL, BF and BIT commands.
			<h3>Return type:</h3>
			int
			<h3>Return value:</h3>
			Size of the value.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="XNGET">

			<h2>XNGET / GETX key number prefix</h2>

			<table border="1">
				<tr><td>Command			</td><td>XNGET</td></tr>
				<tr><td>Available since		</td><td>1.0.0</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>immutable_x.h</td></tr>
			</table>

			<h3>Description:</h3>
			Gets <i>number</i> of key-value pairs after <i>key</i>.<br />Returns ONLY valid pairs, but only if they are matching the <i>prefix</i>.<br />Returns up to ~32'000 elements.
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			First group of element         - array of key and values.<br />Second group of single element - Last key, if there is second page.
						<h3>Example:</h3>
			<pre>set u:001:name  John<br />set u:001:city  LA<br />set u:001:state CA<br />set u:001:phone 1.800.12345678<br /><br />xnget u:001: 1000 u:001:</pre>			
						<h3>MySQL Rosetta:</h3>
			<pre>select key, val from table where key >= [key] and key like '[prefix]%' limit [number]</pre>			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="XRGET">

			<h2>XRGET key number range_end</h2>

			<table border="1">
				<tr><td>Command			</td><td>XRGET</td></tr>
				<tr><td>Available since		</td><td>1.3.7.1</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>immutable_x.h</td></tr>
			</table>

			<h3>Description:</h3>
			Gets <i>number</i> of key-value pairs after <i>key</i>.<br />Returns ONLY valid pairs, but only if they are less than or equal <i>range_end</i>.<br />Returns up to ~32'000 elements.
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			First group of element         - array of key and values.<br />Second group of single element - Last key, if there is second page.
						<h3>Example:</h3>
			<pre>set price:2010-01  5<br />set price:2010-02  6<br />set price:2010-03 10<br />set price:2010-04 16<br />set price:2010-05 22<br /><br />xrget price:2010-02 1000 price:2010-04</pre>			
						<h3>MySQL Rosetta:</h3>
			<pre>select key, val from table where key >= [key] and key < [range_end] limit [number]</pre>			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="XUGET">

			<h2>XUGET key number</h2>

			<table border="1">
				<tr><td>Command			</td><td>XUGET</td></tr>
				<tr><td>Available since		</td><td>1.3.7.1</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>immutable_x.h</td></tr>
			</table>

			<h3>Description:</h3>
			Gets <i>number</i> of key-value pairs after <i>key</i>.<br />Returns ONLY valid pairs, but unlike XNGET and XRGET range is unbounded.<br />Useful for database dump.<br />Returns up to ~32'000 elements.
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			First group of element         - array of key and values.<br />Second group of single element - Last key, if there is second page.
						<h3>Example:</h3>
			<pre>xrget '' 1000</pre>			
						<h3>MySQL Rosetta:</h3>
			<pre>select key, val from table where key >= [key] limit [number]</pre>			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="XNGETKEYS">

			<h2>XNGETKEYS key number prefix</h2>

			<table border="1">
				<tr><td>Command			</td><td>XNGETKEYS</td></tr>
				<tr><td>Available since		</td><td>1.0.0</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>immutable_x.h</td></tr>
			</table>

			<h3>Description:</h3>
			Same as XNGET, but instead of values, return 1.<br>1 is returned because some languages similar to php, may skip the values.
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			First group of element         - array of key and values.<br />Second group of single element - Last key, if there is second page.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="XRGETKEYS">

			<h2>XRGETKEYS key number range_end</h2>

			<table border="1">
				<tr><td>Command			</td><td>XRGETKEYS</td></tr>
				<tr><td>Available since		</td><td>1.3.7.1</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>immutable_x.h</td></tr>
			</table>

			<h3>Description:</h3>
			Same as XRGET, but instead of values, return 1.<br>1 is returned because some languages similar to php, may skip the values.
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			First group of element         - array of key and values.<br />Second group of single element - Last key, if there is second page.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="XUGETKEYS">

			<h2>XUGETKEYS key number</h2>

			<table border="1">
				<tr><td>Command			</td><td>XUGETKEYS</td></tr>
				<tr><td>Available since		</td><td>1.3.7.1</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>immutable_x.h</td></tr>
			</table>

			<h3>Description:</h3>
			Same as XUGET, but instead of values, return 1.<br>1 is returned because some languages similar to php, may skip the values.
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			First group of element         - array of key and values.<br />Second group of single element - Last key, if there is second page.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="COUNT">

			<h2>COUNT key number prefix</h2>

			<table border="1">
				<tr><td>Command			</td><td>COUNT</td></tr>
				<tr><td>Available since		</td><td>1.2.4</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>accumulators_x.h</td></tr>
			</table>

			<h3>Description:</h3>
			Accumulate using COUNT <i>number</i> key-value pairs after <i>key</i>.<br />Accumulate ONLY valid pairs, but only if they are matching the <i>prefix</i>.<br />Accumulate up to 65'536 elements.
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			First element  - count of valid elements.<br />Second element - last key, if there is second page.
						<h3>Example:</h3>
			<pre>set dom:google:google.com  some_data<br />set dom:google:youtube.com some_data<br />set dom:google:gmail.com   some_data<br />set dom:google:blogger.com some_data<br />set dom:google:abc.xyz     some_data<br /><br />getx    dom:google: 1000 dom:google:<br />count   dom:google: 1000 dom:google:</pre>			
						<h3>MySQL Rosetta:</h3>
			<pre>select count(*) from table where key >= [key] and key like '[prefix]%' limit [number]</pre>			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="SUM">

			<h2>SUM key number prefix</h2>

			<table border="1">
				<tr><td>Command			</td><td>SUM</td></tr>
				<tr><td>Available since		</td><td>1.2.4</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>accumulators_x.h</td></tr>
			</table>

			<h3>Description:</h3>
			Accumulate using SUM <i>number</i> key-value pairs after <i>key</i>.<br />Accumulate ONLY valid pairs, but only if they are matching the <i>prefix</i>.<br />Accumulate up to 65'536 elements.
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			First element  - sum of valid elements.<br />Second element - last key, if there is second page.
						<h3>Example:</h3>
			<pre>set visits:20200101 123<br />set visits:20200102 263<br />set visits:20200103 173<br />set visits:20200104 420<br />set visits:20200105 345<br /><br />getx visits:202001 1000 visits:202001<br />sum  visits:202001 1000 visits:202001<br /><br />getx visits:2020   1000 visits:2020<br />sum  visits:2020   1000 visits:2020</pre>			
						<h3>MySQL Rosetta:</h3>
			<pre>select sum(val) from table where key >= [key] and key like '[prefix]%' limit [number]</pre>			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="XNCOUNT">

			<h2>XNCOUNT key prefix</h2>

			<table border="1">
				<tr><td>Command			</td><td>XNCOUNT</td></tr>
				<tr><td>Available since		</td><td>1.2.4</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>accumulators_x.h</td></tr>
			</table>

			<h3>Description:</h3>
			Accumulate using COUNT up to 65'536 key-value pairs after <i>key</i>.<br />Accumulate ONLY valid pairs, but only if they are matching the <i>prefix</i>.
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			First element  - count of valid elements.<br />Second element - last key, if there is second page.
						<h3>Example:</h3>
			<pre>set dom:google:google.com  some_data<br />set dom:google:youtube.com some_data<br />set dom:google:gmail.com   some_data<br />set dom:google:blogger.com some_data<br />set dom:google:abc.xyz     some_data<br /><br />xnget   dom:google: 1000 dom:google:<br />xncount dom:google:      dom:google:</pre>			
						<h3>MySQL Rosetta:</h3>
			<pre>select count(*) from table where key >= [key] and key like '[key]%' limit 65'536</pre>			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="XRCOUNT">

			<h2>XRCOUNT key range_end</h2>

			<table border="1">
				<tr><td>Command			</td><td>XRCOUNT</td></tr>
				<tr><td>Available since		</td><td>1.3.7.1</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>accumulators_x.h</td></tr>
			</table>

			<h3>Description:</h3>
			Accumulate using COUNT up to 65'536 key-value pairs after <i>key</i>.<br />Accumulate ONLY valid pairs, but only if they are less than or equal the <i>range_end</i>.
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			First element  - count of valid elements.<br />Second element - last key, if there is second page.
						<h3>Example:</h3>
			<pre>set dom:google:google.com  some_data<br />set dom:google:youtube.com some_data<br />set dom:google:gmail.com   some_data<br />set dom:google:blogger.com some_data<br />set dom:google:abc.xyz     some_data<br /><br />xrget   dom:google: 1000 dom:google:blogger.com<br />xrcount dom:google:      dom:google:blogger.com</pre>			
						<h3>MySQL Rosetta:</h3>
			<pre>select count(*) from table where key >= [key] and key < [range_end] limit 65'536</pre>			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="XNSUM">

			<h2>XNSUM key prefix</h2>

			<table border="1">
				<tr><td>Command			</td><td>XNSUM</td></tr>
				<tr><td>Available since		</td><td>1.2.4</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>accumulators_x.h</td></tr>
			</table>

			<h3>Description:</h3>
			Accumulate using SUM up to 65'536 key-value pairs after <i>key</i>.<br />Accumulate ONLY valid pairs, but only if they are matching the <i>prefix</i>.
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			First element  - sum of valid elements.<br />Second element - last key, if there is second page.
						<h3>Example:</h3>
			<pre>set visits:20200101 123<br />set visits:20200102 263<br />set visits:20200103 173<br />set visits:20200104 420<br />set visits:20200105 345<br /><br />xnget visits:202001 1000 visits:202001<br />xnsum visits:202001      visits:202001<br /><br />xnget visits:2020   1000 visits:2020<br />xnsum visits:2020        visits:2020</pre>			
						<h3>MySQL Rosetta:</h3>
			<pre>select sum(val) from table where key >= [key] and key like '[prefix]%' limit 65'536</pre>			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="XRSUM">

			<h2>XRSUM key range_end</h2>

			<table border="1">
				<tr><td>Command			</td><td>XRSUM</td></tr>
				<tr><td>Available since		</td><td>1.3.7.1</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>accumulators_x.h</td></tr>
			</table>

			<h3>Description:</h3>
			Accumulate using SUM up to 65'536 key-value pairs after <i>key</i>.<br />Accumulate ONLY valid pairs, but only if they are less than or equal the <i>range_end</i>.
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			First element  - sum of valid elements.<br />Second element - last key, if there is second page.
						<h3>Example:</h3>
			<pre>set visits:20200101 123<br />set visits:20200102 263<br />set visits:20200103 173<br />set visits:20200104 420<br />set visits:20200105 345<br /><br />xrget visits:202001 1000 visits:202003<br />xrsum visits:202001      visits:202003</pre>			
						<h3>MySQL Rosetta:</h3>
			<pre>select sum(val) from table where key >= [key] and key < [range_end] limit 65'536</pre>			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="XNMIN">

			<h2>XNMIN key prefix</h2>

			<table border="1">
				<tr><td>Command			</td><td>XNMIN</td></tr>
				<tr><td>Available since		</td><td>1.2.5</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>accumulators_x.h</td></tr>
			</table>

			<h3>Description:</h3>
			Accumulate using MIN up to 65'536 key-value pairs after <i>key</i>.<br />Accumulate ONLY valid pairs, but only if they are matching the <i>prefix</i>.
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			First element  - min of valid elements.<br />Second element - last key, if there is second page.
						<h3>Example:</h3>
			<pre>set visits:20200101 123<br />set visits:20200102 263<br />set visits:20200103 173<br />set visits:20200104 420<br />set visits:20200105 345<br /><br />xnget visits:202001 1000 visits:202001<br />xnmin visits:202001      visits:202001<br /><br />xnget visits:2020   1000 visits:2020<br />xnmin visits:2020        visits:2020</pre>			
						<h3>MySQL Rosetta:</h3>
			<pre>select min(val) from table where key >= [key] and key like '[prefix]%' limit 65'536</pre>			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="XRMIN">

			<h2>XRMIN key range_end</h2>

			<table border="1">
				<tr><td>Command			</td><td>XRMIN</td></tr>
				<tr><td>Available since		</td><td>1.3.7.1</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>accumulators_x.h</td></tr>
			</table>

			<h3>Description:</h3>
			Accumulate using MIN up to 65'536 key-value pairs after <i>key</i>.<br />Accumulate ONLY valid pairs, but only if they are less than or equal the <i>range_end</i>.
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			First element  - min of valid elements.<br />Second element - last key, if there is second page.
						<h3>Example:</h3>
			<pre>set visits:20200101 123<br />set visits:20200102 263<br />set visits:20200103 173<br />set visits:20200104 420<br />set visits:20200105 345<br /><br />xrget visits:202001 1000 visits:202003<br />xrmin visits:202001      visits:202003</pre>			
						<h3>MySQL Rosetta:</h3>
			<pre>select min(val) from table where key >= [key] and key < [range_end] limit 65'536</pre>			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="XNMAX">

			<h2>XNMAX key prefix</h2>

			<table border="1">
				<tr><td>Command			</td><td>XNMAX</td></tr>
				<tr><td>Available since		</td><td>1.2.5</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>accumulators_x.h</td></tr>
			</table>

			<h3>Description:</h3>
			Accumulate using MAX up to 65'536 key-value pairs after <i>key</i>.<br />Accumulate ONLY valid pairs, but only if they are matching the <i>prefix</i>.
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			First element  - max of valid elements.<br />Second element - last key, if there is second page.
						<h3>Example:</h3>
			<pre>set visits:20200101 123<br />set visits:20200102 263<br />set visits:20200103 173<br />set visits:20200104 420<br />set visits:20200105 345<br /><br />xnget visits:202001 1000 visits:202001<br />xnmax visits:202001      visits:202001<br /><br />xnget visits:2020   1000 visits:2020<br />xnmax visits:2020        visits:2020</pre>			
						<h3>MySQL Rosetta:</h3>
			<pre>select max(val) from table where key >= [key] and key like '[prefix]%' limit 65'536</pre>			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="XRMAX">

			<h2>XRMAX key prefix</h2>

			<table border="1">
				<tr><td>Command			</td><td>XRMAX</td></tr>
				<tr><td>Available since		</td><td>1.3.7.1</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>accumulators_x.h</td></tr>
			</table>

			<h3>Description:</h3>
			Accumulate using MAX up to 65'536 key-value pairs after <i>key</i>.<br />Accumulate ONLY valid pairs, but only if they are less than or equal the <i>range_end</i>.
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			First element  - max of valid elements.<br />Second element - last key, if there is second page.
						<h3>Example:</h3>
			<pre>set visits:20200101 123<br />set visits:20200102 263<br />set visits:20200103 173<br />set visits:20200104 420<br />set visits:20200105 345<br /><br />xrget visits:202001 1000 visits:202003<br />xrmax visits:202001      visits:202003</pre>			
						<h3>MySQL Rosetta:</h3>
			<pre>select max(val) from table where key >= [key] and key < [range_end] limit 65'536</pre>			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="XNFIRST">

			<h2>XNFIRST key prefix</h2>

			<table border="1">
				<tr><td>Command			</td><td>XNFIRST</td></tr>
				<tr><td>Available since		</td><td>1.2.5</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>accumulators_x.h</td></tr>
			</table>

			<h3>Description:</h3>
			Accumulate using FIRST up to 65'536 key-value pairs after <i>key</i>.<br />Accumulate ONLY valid pairs, but only if they are matching the <i>prefix</i>.
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			First element  - max of valid elements.<br />Second element - last key, if there is second page.
						<h3>Example:</h3>
			<pre>set visits:20200101 123<br />set visits:20200102 263<br />set visits:20200103 173<br />set visits:20200104 420<br />set visits:20200105 345<br /><br />xnget   visits:202001 1000 visits:202001<br />xnfirst visits:202001      visits:202001<br /><br />xnget   visits:2020   1000 visits:2020<br />xnfirst visits:2020        visits:2020</pre>			
						<h3>MySQL Rosetta:</h3>
			<pre>select first(val) from table where key >= [key] and key like '[prefix]%' limit 65'536</pre>(Note MySQL does not support first(), but PostgreSQL does)			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="XRFIRST">

			<h2>XRFIRST key prefix</h2>

			<table border="1">
				<tr><td>Command			</td><td>XRFIRST</td></tr>
				<tr><td>Available since		</td><td>1.3.7.1</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>accumulators_x.h</td></tr>
			</table>

			<h3>Description:</h3>
			Accumulate using FIRST up to 65'536 key-value pairs after <i>key</i>.<br />Accumulate ONLY valid pairs, but only if they are less than or equal the <i>range_end</i>.
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			First element  - max of valid elements.<br />Second element - last key, if there is second page.
						<h3>Example:</h3>
			<pre>set visits:20200101 123<br />set visits:20200102 263<br />set visits:20200103 173<br />set visits:20200104 420<br />set visits:20200105 345<br /><br />xrget visits:202001 1000 visits:202003<br />xrmax visits:202001      visits:202003</pre>			
						<h3>MySQL Rosetta:</h3>
			<pre>select first(val) from table where key >= [key] and key < [range_end] limit 65'536</pre>(Note MySQL does not support first(), but PostgreSQL does)			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="XNLAST">

			<h2>XNLAST key prefix</h2>

			<table border="1">
				<tr><td>Command			</td><td>XNLAST</td></tr>
				<tr><td>Available since		</td><td>1.2.5</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>accumulators_x.h</td></tr>
			</table>

			<h3>Description:</h3>
			Accumulate using LAST up to 65'536 key-value pairs after <i>key</i>.<br />Accumulate ONLY valid pairs, but only if they are matching the <i>prefix</i>.
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			First element  - max of valid elements.<br />Second element - last key, if there is second page.
						<h3>Example:</h3>
			<pre>set visits:20200101 123<br />set visits:20200102 263<br />set visits:20200103 173<br />set visits:20200104 420<br />set visits:20200105 345<br /><br />xnget  visits:202001 1000 visits:202001<br />xnlast visits:202001      visits:202001<br /><br />xnget  visits:2020   1000 visits:2020<br />xnlast visits:2020        visits:2020</pre>			
						<h3>MySQL Rosetta:</h3>
			<pre>select last(val) from table where key >= [key] and key like '[prefix]%' limit 65'536</pre>(Note MySQL does not support last(), but PostgreSQL does)			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="XRLAST">

			<h2>XRLAST key prefix</h2>

			<table border="1">
				<tr><td>Command			</td><td>XRLAST</td></tr>
				<tr><td>Available since		</td><td>1.3.7.1</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>accumulators_x.h</td></tr>
			</table>

			<h3>Description:</h3>
			Accumulate using LAST up to 65'536 key-value pairs after <i>key</i>.<br />Accumulate ONLY valid pairs, but only if they are less than or equal the <i>range_end</i>.
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			First element  - max of valid elements.<br />Second element - last key, if there is second page.
						<h3>Example:</h3>
			<pre>set visits:20200101 123<br />set visits:20200102 263<br />set visits:20200103 173<br />set visits:20200104 420<br />set visits:20200105 345<br /><br />xrget visits:202001 1000 visits:202003<br />xrmax visits:202001      visits:202003</pre>			
						<h3>MySQL Rosetta:</h3>
			<pre>select last(val) from table where key >= [key] and key < [range_end] limit 65'536</pre>(Note MySQL does not support last(), but PostgreSQL does)			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="XNAVG">

			<h2>XNAVG key prefix</h2>

			<table border="1">
				<tr><td>Command			</td><td>XNAVG</td></tr>
				<tr><td>Available since		</td><td>1.2.5</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>accumulators_x.h</td></tr>
			</table>

			<h3>Description:</h3>
			Accumulate using <b>*fake*</b> AVG up to 65'536 key-value pairs after <i>key</i>.<br />Accumulate ONLY valid pairs, but only if they are matching the <i>prefix</i>.<br /><br />Since average is not a monoid, XNAVG / XRAVG will return correct result, only when all information is accumulated at once.<br />if it go to next 'pages', result will be incorrect, but still kind of useful.
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			First element  - max of valid elements.<br />Second element - last key, if there is second page.
						<h3>Example:</h3>
			<pre>set visits:20200101 123<br />set visits:20200102 263<br />set visits:20200103 173<br />set visits:20200104 420<br />set visits:20200105 345<br /><br />xnget visits:202001 1000 visits:202001<br />xnavg visits:202001      visits:202001<br /><br />xnget visits:2020   1000 visits:2020<br />xnavg visits:2020        visits:2020</pre>			
						<h3>MySQL Rosetta:</h3>
			<pre>select avg(val) from table where key >= [key] and key like '[prefix]%' limit 65'536</pre>(Note MySQL also will do fake average, if fhis statement is used)			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="XRAVG">

			<h2>XRAVG key prefix</h2>

			<table border="1">
				<tr><td>Command			</td><td>XRAVG</td></tr>
				<tr><td>Available since		</td><td>1.3.7.1</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>accumulators_x.h</td></tr>
			</table>

			<h3>Description:</h3>
			Accumulate using <b>*fake*</b> AVG up to 65'536 key-value pairs after <i>key</i>.<br />Accumulate ONLY valid pairs, but only if they are less than or equal the <i>range_end</i>.<br /><br />Since average is not a monoid, XNAVG / XRAVG will return correct result, only when all information is accumulated at once.<br />if it go to next 'pages', result will be incorrect, but still kind of useful.
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			First element  - max of valid elements.<br />Second element - last key, if there is second page.
						<h3>Example:</h3>
			<pre>set visits:20200101 123<br />set visits:20200102 263<br />set visits:20200103 173<br />set visits:20200104 420<br />set visits:20200105 345<br /><br />xrget visits:202001 1000 visits:202003<br />xrmax visits:202001      visits:202003</pre>			
						<h3>MySQL Rosetta:</h3>
			<pre>select avg(val) from table where key >= [key] and key < [range_end] limit 65'536</pre>(Note MySQL also will do fake average, if fhis statement is used)			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="SET">

			<h2>SET key value [seconds=0]</h2>

			<table border="1">
				<tr><td>Command			</td><td>SET</td></tr>
				<tr><td>Available since		</td><td>1.0.0</td></tr>
				<tr><td>Data lookup complexity	</td><td>WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>mutable.h</td></tr>
			</table>

			<h3>Description:</h3>
			Set <i>key</i> -> <i>value</i> pair, with optional expiration of <i>seconds</i> seconds.
			<h3>Return type:</h3>
			OK
			<h3>Return value:</h3>
			OK
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="MSET">

			<h2>MSET key value [key value]...</h2>

			<table border="1">
				<tr><td>Command			</td><td>MSET</td></tr>
				<tr><td>Available since		</td><td>1.2.17</td></tr>
				<tr><td>Data lookup complexity	</td><td>[number of keys] * WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>mutable.h</td></tr>
			</table>

			<h3>Description:</h3>
			Set multiple <i>key</i> -> <i>value</i> pairs at once.<br />Operation is atomic, so all given keys are set at once.
			<h3>Return type:</h3>
			OK
			<h3>Return value:</h3>
			OK
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="MSETNX">

			<h2>MSETNX key value [key value]...</h2>

			<table border="1">
				<tr><td>Command			</td><td>MSETNX</td></tr>
				<tr><td>Available since		</td><td>1.2.18</td></tr>
				<tr><td>Data lookup complexity	</td><td>[number of keys] * (READ + WRITE)</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>mutable.h</td></tr>
			</table>

			<h3>Description:</h3>
			Set multiple <i>key</i> -> <i>value</i> pairs at once.<br />No keys will set, if just a single key already exists.<br />Operation is atomic, so all given keys are set at once.
			<h3>Return type:</h3>
			int
			<h3>Return value:</h3>
			0 if some of the key value pair exists.<br />1 if none of the key value pair do not exists and keys are set.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="MSETXX">

			<h2>MSETXX key value [key value]...</h2>

			<table border="1">
				<tr><td>Command			</td><td>MSETXX</td></tr>
				<tr><td>Available since		</td><td>1.2.18</td></tr>
				<tr><td>Data lookup complexity	</td><td>[number of keys] * (READ + WRITE)</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>mutable.h</td></tr>
			</table>

			<h3>Description:</h3>
			Set multiple <i>key</i> -> <i>value</i> pairs at once.<br />No keys will set, if just a single key does not exists.<br />Operation is atomic, so all given keys are set at once.
			<h3>Return type:</h3>
			int
			<h3>Return value:</h3>
			0 if some of the key value pair does not exists.<br />1 if none of the key value pair exists and keys are set.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="SETEX">

			<h2>SETEX key seconds value</h2>

			<table border="1">
				<tr><td>Command			</td><td>SETEX</td></tr>
				<tr><td>Available since		</td><td>1.2.11</td></tr>
				<tr><td>Data lookup complexity	</td><td>WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>mutable.h</td></tr>
			</table>

			<h3>Description:</h3>
			Set <i>key</i> -> <i>value</i> pair, if key does not exists, with expiration of <i>seconds</i> seconds.<br />Doing same as <i>SET key value seconds</i>, but in Redis-compatible way.<br />disk.This command is used for PHP session handler.
			<h3>Return type:</h3>
			OK
			<h3>Return value:</h3>
			OK
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="SETNX">

			<h2>SETNX key value [seconds=0]</h2>

			<table border="1">
				<tr><td>Command			</td><td>SETNX</td></tr>
				<tr><td>Available since		</td><td>1.2.11</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ + WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>mutable.h</td></tr>
			</table>

			<h3>Description:</h3>
			Atomically Set value of the <i>key</i>, if key does not exists, with optional expiration of <i>seconds</i> seconds.<br />Note: The command internally GET old key first.
			<h3>Return type:</h3>
			bool
			<h3>Return value:</h3>
			0 if the key value pair exists.<br />1 if the key value pair do not exists and is set.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="SETXX">

			<h2>SETXX key value [seconds=0]</h2>

			<table border="1">
				<tr><td>Command			</td><td>SETXX</td></tr>
				<tr><td>Available since		</td><td>1.2.17</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ + WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>mutable.h</td></tr>
			</table>

			<h3>Description:</h3>
			Atomically Set value of the <i>key</i>, if key exists, with optional expiration of <i>seconds</i> seconds.<br />Note: The command internally GET old key first.
			<h3>Return type:</h3>
			bool
			<h3>Return value:</h3>
			0 if the key value pair exists and is set.<br />1 if the key value pair do not exists.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="APPEND">

			<h2>APPEND key value [seconds=0]</h2>

			<table border="1">
				<tr><td>Command			</td><td>APPEND</td></tr>
				<tr><td>Available since		</td><td>1.3.0</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ + WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>mutable.h</td></tr>
			</table>

			<h3>Description:</h3>
			Atomically Append value of the <i>key</i>, with optional expiration of <i>seconds</i> seconds.<br />Note: The command internally GET old key first.
			<h3>Return type:</h3>
			OK
			<h3>Return value:</h3>
			OK
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="EXPIRE">

			<h2>EXPIRE key seconds</h2>

			<table border="1">
				<tr><td>Command			</td><td>EXPIRE</td></tr>
				<tr><td>Available since		</td><td>1.2.11</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ + WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>mutable.h</td></tr>
			</table>

			<h3>Description:</h3>
			Atomically Change the expiration of the <i>key</i> to <i>seconds</i> seconds.<br />Note: The command internally GET <i>key</i> first.<br />If you can, use SET or SETEX instead.
			<h3>Return type:</h3>
			bool
			<h3>Return value:</h3>
			0 if the key value pair do not exists.<br />1 if the key value pair exists and expiration is set.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="EXPIREAT">

			<h2>EXPIREAT key timestamp</h2>

			<table border="1">
				<tr><td>Command			</td><td>EXPIREAT</td></tr>
				<tr><td>Available since		</td><td>1.3.7.5</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ + WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>mutable.h</td></tr>
			</table>

			<h3>Description:</h3>
			Atomically Change the expiration of the <i>key</i>, so <i>key</i> expire at specific timestamp.<br />If timestamp is in the past, the <i>key</i> is deleted.<br />Note: The command internally GET <i>key</i> first.
			<h3>Return type:</h3>
			bool
			<h3>Return value:</h3>
			0 if the key value pair do not exists.<br />1 if the key value pair exists and expiration is set.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="PERSIST">

			<h2>PERSIST key seconds</h2>

			<table border="1">
				<tr><td>Command			</td><td>PERSIST</td></tr>
				<tr><td>Available since		</td><td>1.2.16</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ + WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>mutable.h</td></tr>
			</table>

			<h3>Description:</h3>
			Atomically remove the expiration of the <i>key</i>.<br />Note: The command internally GET <i>key</i> first.
			<h3>Return type:</h3>
			bool
			<h3>Return value:</h3>
			0 if the key value pair do not exists.<br />1 if the key value pair exists and expiration is removed.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="PERSISTDELETED">

			<h2>PERSISTDELETED key / PERSISTEXPIRED key</h2>

			<table border="1">
				<tr><td>Command			</td><td>PERSISTDELETED</td></tr>
				<tr><td>Available since		</td><td>1.3.4</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ + WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>mutable.h</td></tr>
			</table>

			<h3>Description:</h3>
			Try to undelete a key <i>key</i> by updating expires time.<br />Note: The command internally GET <i>key</i> first.
			<h3>Return type:</h3>
			OK
			<h3>Return value:</h3>
			OK
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="DEL">

			<h2>DEL / UNLINK key [key]...</h2>

			<table border="1">
				<tr><td>Command			</td><td>DEL</td></tr>
				<tr><td>Available since		</td><td>1.0.0</td></tr>
				<tr><td>Data lookup complexity	</td><td>[number of keys] * WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>mutable.h</td></tr>
			</table>

			<h3>Description:</h3>
			Removes <i>key</i>
			<h3>Return type:</h3>
			bool
			<h3>Return value:</h3>
			Always return 1
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="GETSET">

			<h2>GETSET key value [seconds=0]</h2>

			<table border="1">
				<tr><td>Command			</td><td>GETSET</td></tr>
				<tr><td>Available since		</td><td>1.2.11</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ + WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>mutable_get.h</td></tr>
			</table>

			<h3>Description:</h3>
			Gets the value of the <i>key</i>. Exact match.<br />Then atomically Set <i>key</i> -> <i>value</i> pair.<br />This command is often used to get value of atomic counter and reset its value to zero.
			<h3>Return type:</h3>
			string
			<h3>Return value:</h3>
			Value of the key or empty string.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="GETDEL">

			<h2>GETDEL key</h2>

			<table border="1">
				<tr><td>Command			</td><td>GETDEL</td></tr>
				<tr><td>Available since		</td><td>1.2.16</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ + WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>mutable_get.h</td></tr>
			</table>

			<h3>Description:</h3>
			Gets the value of the <i>key</i>. Exact match.<br />Then atomically delete the <i>key</i> -> <i>value</i> pair.<br />
			<h3>Return type:</h3>
			string
			<h3>Return value:</h3>
			Value of the key or empty string.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="GETEX">

			<h2>GETEX key seconds</h2>

			<table border="1">
				<tr><td>Command			</td><td>GETEX</td></tr>
				<tr><td>Available since		</td><td>1.2.16</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ + WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>mutable_get.h</td></tr>
			</table>

			<h3>Description:</h3>
			Gets the value of the <i>key</i>. Exact match.<br />Then atomically Change the expiration of the <i>key</i> to <i>seconds</i> seconds.
			<h3>Return type:</h3>
			string
			<h3>Return value:</h3>
			Value of the key or empty string.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="GETEXAT">

			<h2>GETEXAT key timestamp</h2>

			<table border="1">
				<tr><td>Command			</td><td>GETEXAT</td></tr>
				<tr><td>Available since		</td><td>1.2.16</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ + WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>mutable_get.h</td></tr>
			</table>

			<h3>Description:</h3>
			Gets the value of the <i>key</i>. Exact match.<br />Then atomically Change the expiration of the <i>key</i>, so <i>key</i> expire at specific timestamp.<br />If timestamp is in the past, the <i>key</i> is deleted.
			<h3>Return type:</h3>
			string
			<h3>Return value:</h3>
			Value of the key or empty string.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="GETPERSIST">

			<h2>GETPERSIST key</h2>

			<table border="1">
				<tr><td>Command			</td><td>GETPERSIST</td></tr>
				<tr><td>Available since		</td><td>1.2.16</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ + WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>mutable_get.h</td></tr>
			</table>

			<h3>Description:</h3>
			Gets the value of the <i>key</i>. Exact match.<br />Then atomically remove the expiration of the <i>key</i>.
			<h3>Return type:</h3>
			string
			<h3>Return value:</h3>
			Value of the key or empty string.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="XNDEL">

			<h2>XNDEL key prefix</h2>

			<table border="1">
				<tr><td>Command			</td><td>XNDEL</td></tr>
				<tr><td>Available since		</td><td>1.2.17</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ + [number of keys] * WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>mutable_x.h</td></tr>
			</table>

			<h3>Description:</h3>
			Delete up to 65'536 key-value pairs after <i>key</i>.<br />Delete ONLY valid pairs, and only if they are matching the <i>prefix</i>.
			<h3>Return type:</h3>
			string
			<h3>Return value:</h3>
			Last key, if there is second page.
						<h3>Example:</h3>
			<pre>set u:001:name  John<br />set u:001:city  LA<br />set u:001:state CA<br />set u:001:phone 1.800.12345678<br /><br />xnget u:001: 1000 u:001:<br />xndel u:001:      u:001:</pre>			
						<h3>MySQL Rosetta:</h3>
			<pre>delete from table where key >= [key] and key like '[key]%' limit 65'536</pre>			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="XRDEL">

			<h2>XRDEL key range_end</h2>

			<table border="1">
				<tr><td>Command			</td><td>XRDEL</td></tr>
				<tr><td>Available since		</td><td>1.3.7.1</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ + [number of keys] * WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>mutable_x.h</td></tr>
			</table>

			<h3>Description:</h3>
			Delete up to 65'536 key-value pairs after <i>key</i>.<br />Delete ONLY valid pairs, and only if they are less than or equal <i>range_end</i>.
			<h3>Return type:</h3>
			string
			<h3>Return value:</h3>
			Last key, if there is second page.
						<h3>Example:</h3>
			<pre>set price:2010-01 5<br />set price:2010-02 6<br />set price:2010-03 10<br />set price:2010-04 16<br />set price:2010-05 22<br /><br />xrget price:2010-02 1000 price:2010-04<br />xrdel price:2010-02      price:2010-04</pre>			
						<h3>MySQL Rosetta:</h3>
			<pre>delete from table where key >= [key] and key < [range_end] limit 65'536</pre>			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="XNPERSIST">

			<h2>XNPERSIST key prefix</h2>

			<table border="1">
				<tr><td>Command			</td><td>XNPERSIST</td></tr>
				<tr><td>Available since		</td><td>1.2.17</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ + [number of keys] * WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>mutable_x.h</td></tr>
			</table>

			<h3>Description:</h3>
			Persist up to 65'536 key-value pairs after <i>key</i>.<br />Persist ONLY valid pairs, and only if they are matching the <i>prefix</i>.
			<h3>Return type:</h3>
			string
			<h3>Return value:</h3>
			Last key, if there is second page.
						<h3>Example:</h3>
			<pre>set u:001:name  John<br />set u:001:city  LA<br />set u:001:state CA<br />set u:001:phone 1.800.12345678<br /><br />xnget     u:001: 1000 u:001:<br />xnpersist u:001:      u:001:</pre>			
						<h3>MySQL Rosetta:</h3>
			<pre>update table set expire = 0 where key >= [key] and key like '[key]%' limit 65'536</pre>			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="XRPERSIST">

			<h2>XRPERSIST key prefix</h2>

			<table border="1">
				<tr><td>Command			</td><td>XRPERSIST</td></tr>
				<tr><td>Available since		</td><td>1.3.7.1</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ + [number of keys] * WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>mutable_x.h</td></tr>
			</table>

			<h3>Description:</h3>
			PERSIST up to 65'536 key-value pairs after <i>key</i>.<br />PERSIST ONLY valid pairs, and only if they are less than or equal the <i>range_end</i>.
			<h3>Return type:</h3>
			string
			<h3>Return value:</h3>
			Last key, if there is second page.
						<h3>Example:</h3>
			<pre>set price:2010-01 5<br />set price:2010-02 6<br />set price:2010-03 10<br />set price:2010-04 16<br />set price:2010-05 22<br /><br />xnget     price:2010-02 1000 price:2010-04<br />xnpersist price:2010-02      price:2010-04</pre>			
						<h3>MySQL Rosetta:</h3>
			<pre>update table set expire = 0 where key >= [key] and key < [range_end] limit 65'536</pre>			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="XNEXPIRE">

			<h2>XNEXPIRE key expiration prefix</h2>

			<table border="1">
				<tr><td>Command			</td><td>XNEXPIRE</td></tr>
				<tr><td>Available since		</td><td>1.2.17</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ + [number of keys] * WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>mutable_x.h</td></tr>
			</table>

			<h3>Description:</h3>
			EXPIRE up to 65'536 key-value pairs after <i>key</i>.<br />EXPIRE ONLY valid pairs, and only if they are matching the <i>prefix</i>.
			<h3>Return type:</h3>
			string
			<h3>Return value:</h3>
			Last key, if there is second page.
						<h3>Example:</h3>
			<pre>set u:001:name  John<br />set u:001:city  LA<br />set u:001:state CA<br />set u:001:phone 1.800.12345678<br /><br />xnget    u:001: 1000 u:001:<br />xnexpire u:001:   90 u:001:</pre>			
						<h3>MySQL Rosetta:</h3>
			<pre>update table set expire = [expiration] where key >= [key] and key like '[key]%' limit 65'536</pre>			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="XREXPIRE">

			<h2>XREXPIRE key expiration prefix</h2>

			<table border="1">
				<tr><td>Command			</td><td>XREXPIRE</td></tr>
				<tr><td>Available since		</td><td>1.3.7.1</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ + [number of keys] * WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>mutable_x.h</td></tr>
			</table>

			<h3>Description:</h3>
			EXPIRE up to 65'536 key-value pairs after <i>key</i>.<br />EXPIRE ONLY valid pairs, and only if they are less than or equal the <i>range_end</i>.
			<h3>Return type:</h3>
			string
			<h3>Return value:</h3>
			Last key, if there is second page.
						<h3>Example:</h3>
			<pre>set price:2010-01 5<br />set price:2010-02 6<br />set price:2010-03 10<br />set price:2010-04 16<br />set price:2010-05 22<br /><br />xrget    price:2010-02 1000 price:2010-04<br />xrexpire price:2010-02   90 price:2010-04</pre>			
						<h3>MySQL Rosetta:</h3>
			<pre>update table set expire = [expiration] where key >= [key] and key < [range_end] limit 65'536</pre>			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="XNEXPIREAT">

			<h2>XNEXPIREAT key timestamp prefix</h2>

			<table border="1">
				<tr><td>Command			</td><td>XNEXPIREAT</td></tr>
				<tr><td>Available since		</td><td>1.3.7.5</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ + [number of keys] * WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>mutable_x.h</td></tr>
			</table>

			<h3>Description:</h3>
			EXPIREAT up to 65'536 key-value pairs after <i>key</i>.<br />EXPIREAT ONLY valid pairs, and only if they are matching the <i>prefix</i>.
			<h3>Return type:</h3>
			string
			<h3>Return value:</h3>
			Last key, if there is second page.
						<h3>Example:</h3>
			<pre>set u:001:name  John<br />set u:001:city  LA<br />set u:001:state CA<br />set u:001:phone 1.800.12345678<br /><br />xnget      u:001:       1000 u:001:<br />xnexpireat u:001: 1830290400 u:001:</pre>			
						<h3>MySQL Rosetta:</h3>
			<pre>update table set expire_at = [expiration] where key >= [key] and key like '[key]%' limit 65'536</pre>			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="XREXPIREAT">

			<h2>XREXPIREAT key timestamp prefix</h2>

			<table border="1">
				<tr><td>Command			</td><td>XREXPIREAT</td></tr>
				<tr><td>Available since		</td><td>1.3.7.5</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ + [number of keys] * WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>mutable_x.h</td></tr>
			</table>

			<h3>Description:</h3>
			EXPIREAT up to 65'536 key-value pairs after <i>key</i>.<br />EXPIREAT ONLY valid pairs, and only if they are less than or equal the <i>range_end</i>.
			<h3>Return type:</h3>
			string
			<h3>Return value:</h3>
			Last key, if there is second page.
						<h3>Example:</h3>
			<pre>set price:2010-01 5<br />set price:2010-02 6<br />set price:2010-03 10<br />set price:2010-04 16<br />set price:2010-05 22<br /><br />xrget      price:2010-02       1000 price:2010-04<br />xrexpireat price:2010-02 1830290400 price:2010-04</pre>			
						<h3>MySQL Rosetta:</h3>
			<pre>update table set expire_at = [expiration] where key >= [key] and key < [range_end] limit 65'536</pre>			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="CAS">

			<h2>CAS key old_value new_value [seconds=0]</h2>

			<table border="1">
				<tr><td>Command			</td><td>CAS</td></tr>
				<tr><td>Available since		</td><td>1.2.17</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ + WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>cas.h</td></tr>
			</table>

			<h3>Description:</h3>
			Set the value of the <i>key</i> to <i>new_value</i>,only if the current value of the <i>key</i>  is equal to <i>old_value</i>.<br />You can check C++ command std::compare_exchange_weak() / std::compare_exchange_strong as well.<br />This command is compatible to Alibaba Tair Cloud.
			<h3>Return type:</h3>
			bool
			<h3>Return value:</h3>
			if the key value is set or not
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="CAD">

			<h2>CAD key old_value</h2>

			<table border="1">
				<tr><td>Command			</td><td>CAD</td></tr>
				<tr><td>Available since		</td><td>1.2.17</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ + WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>cas.h</td></tr>
			</table>

			<h3>Description:</h3>
			Delete the the <i>key</i>,only if the current value of the <i>key</i>  is equal to <i>old_value</i>.<br />This command is compatible to Alibaba Tair Cloud.
			<h3>Return type:</h3>
			bool
			<h3>Return value:</h3>
			if the key is removed or not
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="COPY">

			<h2>COPY old_key new_key</h2>

			<table border="1">
				<tr><td>Command			</td><td>COPY</td></tr>
				<tr><td>Available since		</td><td>1.2.16</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ + WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>copy.h</td></tr>
			</table>

			<h3>Description:</h3>
			Atomically copy the <i>old_key</i> to the <i>new_key</i>.<br />Note: The command internally GET <i>old_key</i> first.
			<h3>Return type:</h3>
			bool
			<h3>Return value:</h3>
			0 if the key value pair do not exists.<br />1 if the key value pair exists and name is changed.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="COPYNX">

			<h2>COPYNX old_key new_key</h2>

			<table border="1">
				<tr><td>Command			</td><td>COPYNX</td></tr>
				<tr><td>Available since		</td><td>1.2.16</td></tr>
				<tr><td>Data lookup complexity	</td><td>2 * READ + WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>copy.h</td></tr>
			</table>

			<h3>Description:</h3>
			Atomically copy the <i>old_key</i> to the <i>new_key</i>, if <i>new_key</i> does not exists.<br />Note: The command internally GET <i>old_key</i> and <i>new_key</i> first.<br />Note: Redis does not support this operation.
			<h3>Return type:</h3>
			bool
			<h3>Return value:</h3>
			0 if the key value pair do not exists.<br />1 if the key value pair exists and name is changed.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="RENAME">

			<h2>RENAME old_key new_key / MOVE old_key new_key</h2>

			<table border="1">
				<tr><td>Command			</td><td>RENAME</td></tr>
				<tr><td>Available since		</td><td>1.2.16</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ + WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>copy.h</td></tr>
			</table>

			<h3>Description:</h3>
			Atomically renames <i>old_key</i> to <i>new_key</i>.
			<h3>Return type:</h3>
			bool
			<h3>Return value:</h3>
			0 if the key value pair do not exists.<br />1 if the key value pair exists and name is changed.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="RENAMENX">

			<h2>RENAMENX old_key new_key / MOVENX old_key new_key</h2>

			<table border="1">
				<tr><td>Command			</td><td>RENAMENX</td></tr>
				<tr><td>Available since		</td><td>1.2.16</td></tr>
				<tr><td>Data lookup complexity	</td><td>2 * READ + WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>copy.h</td></tr>
			</table>

			<h3>Description:</h3>
			Atomically renames <i>old_key</i> to <i>new_key</i>, if <i>new_key</i> does not exists.<br />Note: The command internally GET <i>old_key</i> and <i>new_key</i> first.
			<h3>Return type:</h3>
			bool
			<h3>Return value:</h3>
			0 if the key value pair do not exists.<br />1 if the key value pair exists and name is changed.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="INCR">

			<h2>INCR / INCRBY key [increase value=1]</h2>

			<table border="1">
				<tr><td>Command			</td><td>INCR</td></tr>
				<tr><td>Available since		</td><td>1.1.0</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ + WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>counter.h</td></tr>
			</table>

			<h3>Description:</h3>
			Atomically increase numerical value of the <i>key</i> with <i>increase value</i>.<br />Uses <b>int64_t</b> as a number type.
			<h3>Return type:</h3>
			string (int)
			<h3>Return value:</h3>
			New increased value.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="DECR">

			<h2>DECR / DECRBY key [decrease value=1]</h2>

			<table border="1">
				<tr><td>Command			</td><td>DECR</td></tr>
				<tr><td>Available since		</td><td>1.1.0</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ + WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>counter.h</td></tr>
			</table>

			<h3>Description:</h3>
			Atomically decrease numerical value of the <i>key</i> with <i>decrease value</i>.<br />Uses <b>int64_t</b> as a number type.
			<h3>Return type:</h3>
			string (int)
			<h3>Return value:</h3>
			New decrease value.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="INCRTO">

			<h2>INCRTO key value</h2>

			<table border="1">
				<tr><td>Command			</td><td>INCRTO</td></tr>
				<tr><td>Available since		</td><td>1.3.7.7</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ + WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>counter.h</td></tr>
			</table>

			<h3>Description:</h3>
			Atomically increase numerical value of the <i>key</i> to <i>value</i>, but only if new value is greater than old value.<br />Uses <b>int64_t</b> as a number type.<br />Useful for single heavy hitter.
			<h3>Return type:</h3>
			string (int)
			<h3>Return value:</h3>
			New increased value.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="DECRTO">

			<h2>DECRTO key value</h2>

			<table border="1">
				<tr><td>Command			</td><td>DECRTO</td></tr>
				<tr><td>Available since		</td><td>1.3.7.7</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ + WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>counter.h</td></tr>
			</table>

			<h3>Description:</h3>
			Atomically decrease numerical value of the <i>key</i> to <i>value</i>, but only if new value is less than old value.<br />Uses <b>int64_t</b> as a number type.<br />Useful for single heavy hitter.
			<h3>Return type:</h3>
			string (int)
			<h3>Return value:</h3>
			New increased value.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="HGETALL">

			<h2>HGETALL key</h2>

			<table border="1">
				<tr><td>Command			</td><td>HGETALL</td></tr>
				<tr><td>Available since		</td><td>1.2.17</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>immutable_x.h</td></tr>
			</table>

			<h3>Description:</h3>
			Get <i>key</i> hash.<br />Returns up to 1'000 elements.<br />Works exactly as Redis HGETALL, except internally set key for each value.
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			array of subkey and values from key hash
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="HGETKEYS">

			<h2>HGETKEYS key</h2>

			<table border="1">
				<tr><td>Command			</td><td>HGETKEYS</td></tr>
				<tr><td>Available since		</td><td>1.2.19</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>immutable_x.h</td></tr>
			</table>

			<h3>Description:</h3>
			Get <i>key</i> hash.<br />Returns up to 1'000 elements.<br />Works exactly as Redis HGETALL, except internally set key for each value.
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			array of subkey from key hash
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="HGETVALS">

			<h2>HGETVALS key</h2>

			<table border="1">
				<tr><td>Command			</td><td>HGETVALS</td></tr>
				<tr><td>Available since		</td><td>1.2.19</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>immutable_x.h</td></tr>
			</table>

			<h3>Description:</h3>
			Get <i>key</i> hash.<br />Returns up to 1'000 elements.<br />Works exactly as Redis HGETVALS, except internally set key for each value.
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			array of values from key hash
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="HLEN">

			<h2>HLEN key</h2>

			<table border="1">
				<tr><td>Command			</td><td>HLEN</td></tr>
				<tr><td>Available since		</td><td>1.2.19</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>immutable_x.h</td></tr>
			</table>

			<h3>Description:</h3>
			Get <i>key</i> hash.<br />Counts up to 1'000 elements.<br />Works exactly as Redis HLEN, except internally set key for each value.
			<h3>Return type:</h3>
			int
			<h3>Return value:</h3>
			number of elements in key hash
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="HGET">

			<h2>HGET key subkey</h2>

			<table border="1">
				<tr><td>Command			</td><td>HGET</td></tr>
				<tr><td>Available since		</td><td>1.2.17</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>immutable.h</td></tr>
			</table>

			<h3>Description:</h3>
			Get <i>key</i> -> <i>subkey</i> hash.<br />Works exactly as Redis HGET, except internally set key for each value.
			<h3>Return type:</h3>
			string
			<h3>Return value:</h3>
			Value of the key -> subkey hash or empty string.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="HMGET">

			<h2>HMGET key subkey [subkey]...</h2>

			<table border="1">
				<tr><td>Command			</td><td>HMGET</td></tr>
				<tr><td>Available since		</td><td>1.2.17</td></tr>
				<tr><td>Data lookup complexity	</td><td>[number of keys] * READ</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>immutable.h</td></tr>
			</table>

			<h3>Description:</h3>
			Get <i>key</i> -> <i>subkey</i> hash.<br />Works exactly as Redis HMGET, except internally set key for each value.<br />If you can, use HGETALL it is much faster.
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			Value of the key -> subkey hash or empty string.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="HEXISTS">

			<h2>HEXISTS key subkey</h2>

			<table border="1">
				<tr><td>Command			</td><td>HEXISTS</td></tr>
				<tr><td>Available since		</td><td>1.2.17</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>immutable.h</td></tr>
			</table>

			<h3>Description:</h3>
			Get information if <i>key</i> -> <i>subkey</i> hash exists.<br /><br />Works exactly as Redis HSET, except internally set key for each value.<br />Operation is not recommended, because it is as fast as if you get the hash itself.
			<h3>Return type:</h3>
			bool
			<h3>Return value:</h3>
			0 if the key -> subkey hash do not exists.<br />1 if the key -> subkey hash exists.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="HSET">

			<h2>HSET key subkey val [seconds]</h2>

			<table border="1">
				<tr><td>Command			</td><td>HSET</td></tr>
				<tr><td>Available since		</td><td>1.2.17</td></tr>
				<tr><td>Data lookup complexity	</td><td>WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>mutable.h</td></tr>
			</table>

			<h3>Description:</h3>
			Set <i>key</i> -> <i>subkey</i> -> <i>value</i> hash, with optional expiration of <i>seconds</i> seconds.<br />Works exactly as Redis HSET, except internally set key for each value.
			<h3>Return type:</h3>
			OK
			<h3>Return value:</h3>
			OK
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="HMSET">

			<h2>HMSET key subkey value [subkey value]...</h2>

			<table border="1">
				<tr><td>Command			</td><td>HMSET</td></tr>
				<tr><td>Available since		</td><td>1.2.17</td></tr>
				<tr><td>Data lookup complexity	</td><td>WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>mutable.h</td></tr>
			</table>

			<h3>Description:</h3>
			Set <i>key</i> -> <i>subkey</i> -> <i>value</i> hash.<br />Works exactly as Redis HMSET, except internally set key for each value.
			<h3>Return type:</h3>
			OK
			<h3>Return value:</h3>
			OK
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="HDEL">

			<h2>HDEL key subkey [subkey]...</h2>

			<table border="1">
				<tr><td>Command			</td><td>HDEL</td></tr>
				<tr><td>Available since		</td><td>1.2.17</td></tr>
				<tr><td>Data lookup complexity	</td><td>[number of keys] * WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>mutable.h</td></tr>
			</table>

			<h3>Description:</h3>
			Removes <i>key</i> -> <i>subkey</i> hash.<br />Works exactly as Redis HSET, except internally set key for each value.
			<h3>Return type:</h3>
			bool
			<h3>Return value:</h3>
			Always return 1
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="HDELALL">

			<h2>HDELALL key</h2>

			<table border="1">
				<tr><td>Command			</td><td>HDELALL</td></tr>
				<tr><td>Available since		</td><td>1.3.4</td></tr>
				<tr><td>Data lookup complexity	</td><td>[number of keys] * WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>mutable_x.h</td></tr>
			</table>

			<h3>Description:</h3>
			Delete up to 10'000 key-value pairs from hash <i>key</i>.<br />Works exactly as Redis DEL [hash key].
			<h3>Return type:</h3>
			bool
			<h3>Return value:</h3>
			1 if all keys are removed, 0 if keys remains
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="HPERSISTALL">

			<h2>HPERSISTALL key</h2>

			<table border="1">
				<tr><td>Command			</td><td>HPERSISTALL</td></tr>
				<tr><td>Available since		</td><td>1.3.4</td></tr>
				<tr><td>Data lookup complexity	</td><td>[number of keys] * WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>mutable_x.h</td></tr>
			</table>

			<h3>Description:</h3>
			PERSIST up to 10'000 key-value pairs from hash <i>key</i>.<br />Works exactly as Redis PERSIST [hash key].
			<h3>Return type:</h3>
			bool
			<h3>Return value:</h3>
			1 if all keys are removed, 0 if keys remains
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="HEXPIREALL">

			<h2>HEXPIREALL key</h2>

			<table border="1">
				<tr><td>Command			</td><td>HEXPIREALL</td></tr>
				<tr><td>Available since		</td><td>1.3.4</td></tr>
				<tr><td>Data lookup complexity	</td><td>[number of keys] * WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>mutable_x.h</td></tr>
			</table>

			<h3>Description:</h3>
			EXPIRE up to 10'000 key-value pairs from hash <i>key</i>.<br />Works exactly as Redis EXPIRE [hash key].
			<h3>Return type:</h3>
			bool
			<h3>Return value:</h3>
			1 if all keys are removed, 0 if keys remains
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="HEXPIREATALL">

			<h2>HEXPIREATALL key</h2>

			<table border="1">
				<tr><td>Command			</td><td>HEXPIREATALL</td></tr>
				<tr><td>Available since		</td><td>1.3.7.5</td></tr>
				<tr><td>Data lookup complexity	</td><td>[number of keys] * WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>mutable_x.h</td></tr>
			</table>

			<h3>Description:</h3>
			EXPIREAT up to 10'000 key-value pairs from hash <i>key</i>.<br />Works exactly as Redis EXPIREAT [hash key].
			<h3>Return type:</h3>
			bool
			<h3>Return value:</h3>
			1 if all keys are removed, 0 if keys remains
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="SADD">

			<h2>SADD key val [expiration]</h2>

			<table border="1">
				<tr><td>Command			</td><td>SADD</td></tr>
				<tr><td>Available since		</td><td>1.2.16</td></tr>
				<tr><td>Data lookup complexity	</td><td>WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>queue.h</td></tr>
			</table>

			<h3>Description:</h3>
			Atomically add <i>value</i> into queue <i>key</i>, with optional expiration of seconds seconds.<br />Works exactly as Redis SADD, except internally set key for each value.
			<h3>Return type:</h3>
			OK
			<h3>Return value:</h3>
			OK
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="SPOP">

			<h2>SPOP key</h2>

			<table border="1">
				<tr><td>Command			</td><td>SPOP</td></tr>
				<tr><td>Available since		</td><td>1.2.16</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ + WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>queue.h</td></tr>
			</table>

			<h3>Description:</h3>
			Atomically remove single element from queue <i>key</i>.<br />Works exactly as Redis SPOP, except internally set <b>control key</b> for each queue, also remove the key for the value.
			<h3>Return type:</h3>
			string (int)
			<h3>Return value:</h3>
			Value of the removed element or empty string.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="BITSET">

			<h2>BITSET / BITMSET / SETBIT key index value [index value]...</h2>

			<table border="1">
				<tr><td>Command			</td><td>BITSET</td></tr>
				<tr><td>Available since		</td><td>1.2.17</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ + WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>bitset.h</td></tr>
			</table>

			<h3>Description:</h3>
			Set bit(s) of the <i>key</i> with <i>index</i> to <i>value</i> (0/1).<br />Read Bitset information document.
			<h3>Return type:</h3>
			OK
			<h3>Return value:</h3>
			OK
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="BITGET">

			<h2>BITGET / GETBIT key index</h2>

			<table border="1">
				<tr><td>Command			</td><td>BITGET</td></tr>
				<tr><td>Available since		</td><td>1.2.17</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>bitset.h</td></tr>
			</table>

			<h3>Description:</h3>
			Get bit of the <i>key</i> with <i>index</i>.<br />Read Bitset information document.
			<h3>Return type:</h3>
			string (int)
			<h3>Return value:</h3>
			0 / 1
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="BITMGET">

			<h2>BITMGET key index [index]...</h2>

			<table border="1">
				<tr><td>Command			</td><td>BITMGET</td></tr>
				<tr><td>Available since		</td><td>1.3.0</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>bitset.h</td></tr>
			</table>

			<h3>Description:</h3>
			Get bit(s) of the <i>key</i> with <i>index</i><br />Read Bitset information document.
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			0 / 1
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="BITCOUNT">

			<h2>BITCOUNT key</h2>

			<table border="1">
				<tr><td>Command			</td><td>BITCOUNT</td></tr>
				<tr><td>Available since		</td><td>1.2.17</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>bitset.h</td></tr>
			</table>

			<h3>Description:</h3>
			Calculate bitcount (popcount) of the <i>key</i>,<br />e.g. number of bits set to 1.
			<h3>Return type:</h3>
			string (int)
			<h3>Return value:</h3>
			bitcount
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="BITMAX">

			<h2>BITMAX</h2>

			<table border="1">
				<tr><td>Command			</td><td>BITMAX</td></tr>
				<tr><td>Available since		</td><td>1.2.17</td></tr>
				<tr><td>Data lookup complexity	</td><td>n/a</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>n/a</td></tr>
				<tr><td>Module			</td><td>bitset.h</td></tr>
			</table>

			<h3>Description:</h3>
			Return maximum suported index,<br />it is limited of max value size - currently 1MB * 8 bits = 8'388'608 bits.
			<h3>Return type:</h3>
			string (int)
			<h3>Return value:</h3>
			Maximum suported index.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="GEOGET">

			<h2>GEOGET / GEOSCORE key name</h2>

			<table border="1">
				<tr><td>Command			</td><td>GEOGET</td></tr>
				<tr><td>Available since		</td><td>1.3.4.2</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>geo.h</td></tr>
			</table>

			<h3>Description:</h3>
			Retrieve the specified geospatial item (<i>name</i>) from the specified <i>key</i>.
			<h3>Return type:</h3>
			string
			<h3>Return value:</h3>
			[latitude],[longitude],[geohash]
						<h3>Example:</h3>
			<pre>geoadd places 42.69174997126510 23.32100561258516 Boho<br />geoadd places 42.68342508736217 23.31633975360111 Chevermeto<br />geoget places Boho<br />geoget places Chevermeto</pre>			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="GEOMGET">

			<h2>GEOMGET key name [name]...</h2>

			<table border="1">
				<tr><td>Command			</td><td>GEOMGET</td></tr>
				<tr><td>Available since		</td><td>1.3.4.2</td></tr>
				<tr><td>Data lookup complexity	</td><td>[number of keys] * READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>geo.h</td></tr>
			</table>

			<h3>Description:</h3>
			Retrieve the specified geospatial items (<i>name</i>) from the specified <i>key</i>.
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			array
						<h3>Example:</h3>
			<pre>geoadd  places 42.69174997126510 23.32100561258516 Boho<br />geoadd  places 42.68342508736217 23.31633975360111 Chevermeto<br />geomget places Boho Chevermeto NonExistent</pre>			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="GEOADD">

			<h2>GEOADD key latitude longitude name [latitude longitude name]...</h2>

			<table border="1">
				<tr><td>Command			</td><td>GEOADD</td></tr>
				<tr><td>Available since		</td><td>1.3.4.2</td></tr>
				<tr><td>Data lookup complexity	</td><td>[number of keys] * (READ + 3 * WRITE)</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>geo.h</td></tr>
			</table>

			<h3>Description:</h3>
			Adds the specified geospatial items (<i>latitude</i>, <i>longitude</i>, <i>name</i>) to the specified <i>key</i>.<br />Command is not Redis compatible, because <i>latitude</i> and <i>longitude</i> are not in the same order as in Redis.
			<h3>Return type:</h3>
			OK
			<h3>Return value:</h3>
			OK
						<h3>Example:</h3>
			<pre>geoadd places 42.69174997126510 23.32100561258516 Boho<br />geoadd places 42.68342508736217 23.31633975360111 Chevermeto<br />xnget  places 1000 places</pre>			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="GEOREM">

			<h2>GEOREM / GEOREMOVE / GEODEL key name [name]...</h2>

			<table border="1">
				<tr><td>Command			</td><td>GEOREM</td></tr>
				<tr><td>Available since		</td><td>1.3.4.2</td></tr>
				<tr><td>Data lookup complexity	</td><td>[number of keys] * (READ + 2 * WRITE)</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>geo.h</td></tr>
			</table>

			<h3>Description:</h3>
			Removes the specified geospatial items (<i>name</i>) from the specified <i>key</i>.
			<h3>Return type:</h3>
			OK
			<h3>Return value:</h3>
			OK
						<h3>Example:</h3>
			<pre>geoadd places 42.69174997126510 23.32100561258516 Boho<br />geoadd places 42.68342508736217 23.31633975360111 Chevermeto<br />xnget  places 1000 places<br />georem places Chevermeto<br />xnget  places 1000 places</pre>			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="GEORADIUS">

			<h2>GEORADIUS / GEORADIUS_RO key latitude longitude radius</h2>

			<table border="1">
				<tr><td>Command			</td><td>GEORADIUS</td></tr>
				<tr><td>Available since		</td><td>1.3.4.2</td></tr>
				<tr><td>Data lookup complexity	</td><td>N * READ, were N &isin; { 9, 6, 4, 2, 1 }</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>geo.h</td></tr>
			</table>

			<h3>Description:</h3>
			Retrieve all geospatial items from the specified <i>key</i> that are within <i>radius</i> <b>meters</b> from specific <i>latitude</i> <i>longitude</i> position.<br />Unlike Redis, this works only in meters.<br />Similar to Redis this works only on planet Earth :)
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			array
						<h3>Example:</h3>
			<pre>geoadd    places 42.69174997126510 23.32100561258516 Boho<br />geoadd    places 42.68342508736217 23.31633975360111 Chevermeto<br />georadius places 42.69209558730095 23.32479448130661 450</pre>			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="GEODIST">

			<h2>GEODIST key name1 name2</h2>

			<table border="1">
				<tr><td>Command			</td><td>GEODIST</td></tr>
				<tr><td>Available since		</td><td>1.3.4.2</td></tr>
				<tr><td>Data lookup complexity	</td><td>2 * READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>geo.h</td></tr>
			</table>

			<h3>Description:</h3>
			Return the distance between two members (<i>name1</i> and <i>name2</i>) from the <i>key</i><br />Unlike Redis, this works only in meters.<br />Similar to Redis this works only on planet Earth :)
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			array
						<h3>Example:</h3>
			<pre>geoadd  places 42.69174997126510 23.32100561258516 Boho<br />geoadd  places 42.68342508736217 23.31633975360111 Chevermeto<br />geodist places Boho Chevermeto</pre>			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="GEOENCODE">

			<h2>GEOENCODE latitude longitude</h2>

			<table border="1">
				<tr><td>Command			</td><td>GEOENCODE</td></tr>
				<tr><td>Available since		</td><td>1.3.4.2</td></tr>
				<tr><td>Data lookup complexity	</td><td>N/A</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>n/a</td></tr>
				<tr><td>Module			</td><td>geo.h</td></tr>
			</table>

			<h3>Description:</h3>
			Encode <i>latitude</i> and <i>longitude</i> into geohash
			<h3>Return type:</h3>
			string
			<h3>Return value:</h3>
			[latitude],[longitude],[geohash]
						<h3>Example:</h3>
			<pre>geoencode 42.69174997126510 23.32100561258516</pre>			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="GEODECODE">

			<h2>GEODECODE geohash</h2>

			<table border="1">
				<tr><td>Command			</td><td>GEODECODE</td></tr>
				<tr><td>Available since		</td><td>1.3.4.2</td></tr>
				<tr><td>Data lookup complexity	</td><td>N/A</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>n/a</td></tr>
				<tr><td>Module			</td><td>geo.h</td></tr>
			</table>

			<h3>Description:</h3>
			Encode <i>geohash</i> into latitude and longitude.<br />Note if you encode coordinates into geohash and then decode the hash, result may be slightly different coordinates
			<h3>Return type:</h3>
			string
			<h3>Return value:</h3>
			[latitude],[longitude],[geohash]
						<h3>Example:</h3>
			<pre>geodecode sx8dfevc6z40</pre>			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="PFADD">

			<h2>PFADD / HLLADD key value [value]...</h2>

			<table border="1">
				<tr><td>Command			</td><td>PFADD</td></tr>
				<tr><td>Available since		</td><td>1.2.17</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ + [number of keys] * WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>hll.h</td></tr>
			</table>

			<h3>Description:</h3>
			Add <i>value</i> into HLL <i>key</i>.<br />Read HLL information document.
			<h3>Return type:</h3>
			string (int)
			<h3>Return value:</h3>
			always returns 1
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="PFRESERVE">

			<h2>PFRESERVE / HLLRESERVE key</h2>

			<table border="1">
				<tr><td>Command			</td><td>PFRESERVE</td></tr>
				<tr><td>Available since		</td><td>1.2.30</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ + WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>hll.h</td></tr>
			</table>

			<h3>Description:</h3>
			Create new, empty HLL <i>key</i>.<br />Read HLL information document.
			<h3>Return type:</h3>
			OK
			<h3>Return value:</h3>
			OK
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="PFCOUNT">

			<h2>PFCOUNT / HLLCOUNT [key]...</h2>

			<table border="1">
				<tr><td>Command			</td><td>PFCOUNT</td></tr>
				<tr><td>Available since		</td><td>1.2.17</td></tr>
				<tr><td>Data lookup complexity	</td><td>[number of keys] * READ</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>hll.h</td></tr>
			</table>

			<h3>Description:</h3>
			Estimate count of HLL union of provided <i>key</i>.<br />Works with single key too, but returns standard estimation.<br />Works without key too, but returns 0.<br />Read HLL information document.
			<h3>Return type:</h3>
			string (int)
			<h3>Return value:</h3>
			estimated count
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="PFINTERSECT">

			<h2>PFINTERSECT / HLLINTERSECT [key1] [key2] [key3] [key4] [key5]</h2>

			<table border="1">
				<tr><td>Command			</td><td>PFINTERSECT</td></tr>
				<tr><td>Available since		</td><td>1.2.17</td></tr>
				<tr><td>Data lookup complexity	</td><td>[number of keys] * READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>hll.h</td></tr>
			</table>

			<h3>Description:</h3>
			Estimate count of the intersection of up to 5 keys, using HLL unions.<br />Works with single key too, but returns standard estimation.<br />Works without key too, but returns 0.<br />Read HLL information document.
			<h3>Return type:</h3>
			string (int)
			<h3>Return value:</h3>
			estimated count of intersection
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="PFMERGE">

			<h2>PFMERGE / HLLMERGE dest_key [key1] [key2] [key3] [key4] [key5]</h2>

			<table border="1">
				<tr><td>Command			</td><td>PFMERGE</td></tr>
				<tr><td>Available since		</td><td>1.2.17</td></tr>
				<tr><td>Data lookup complexity	</td><td>[number of keys] * READ + WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>hll.h</td></tr>
			</table>

			<h3>Description:</h3>
			Make a HLL union of up to 5 keys and store it in <i>dest_key</i><br />Works with single key too. Works without key too.
			<h3>Return type:</h3>
			OK
			<h3>Return value:</h3>
			Value of the removed element or empty string.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="PFBITS">

			<h2>PFBITS / HLLBITS</h2>

			<table border="1">
				<tr><td>Command			</td><td>PFBITS</td></tr>
				<tr><td>Available since		</td><td>1.2.17</td></tr>
				<tr><td>Data lookup complexity	</td><td>n/a</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>n/a</td></tr>
				<tr><td>Module			</td><td>hll.h</td></tr>
			</table>

			<h3>Description:</h3>
			return HLL bits
			<h3>Return type:</h3>
			string (int)
			<h3>Return value:</h3>
			HLL bits
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="PFERROR">

			<h2>PFERROR / HLLERROR</h2>

			<table border="1">
				<tr><td>Command			</td><td>PFERROR</td></tr>
				<tr><td>Available since		</td><td>1.2.17</td></tr>
				<tr><td>Data lookup complexity	</td><td>n/a</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>n/a</td></tr>
				<tr><td>Module			</td><td>hll.h</td></tr>
			</table>

			<h3>Description:</h3>
			return HLL error rate
			<h3>Return type:</h3>
			string (int)
			<h3>Return value:</h3>
			HLL error rate as percent, but multiplied to 1'00'00
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="BFADD">

			<h2>BFADD / BFMADD key bits hash value [value]...</h2>

			<table border="1">
				<tr><td>Command			</td><td>BFADD</td></tr>
				<tr><td>Available since		</td><td>1.3.1</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ + WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>bf.h</td></tr>
			</table>

			<h3>Description:</h3>
			Add (insert) <i>value</i>'s into the bloom filter with size <i>bits</i> and number of <i>hash</i> functions.<br />Read BF information document.
			<h3>Return type:</h3>
			OK
			<h3>Return value:</h3>
			OK
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="BFRESERVE">

			<h2>BFRESERVE key bits hash</h2>

			<table border="1">
				<tr><td>Command			</td><td>BFRESERVE</td></tr>
				<tr><td>Available since		</td><td>1.3.1</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ + WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>bf.h</td></tr>
			</table>

			<h3>Description:</h3>
			Create new, empty bloom filter with size <i>bits</i> number of <i>hash</i> functions.<br />Value of <i>hash</i> is not used.<br />Read BF information document.
			<h3>Return type:</h3>
			OK
			<h3>Return value:</h3>
			OK
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="BFEXISTS">

			<h2>BFEXISTS key bits hash value</h2>

			<table border="1">
				<tr><td>Command			</td><td>BFEXISTS</td></tr>
				<tr><td>Available since		</td><td>1.3.1</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>bf.h</td></tr>
			</table>

			<h3>Description:</h3>
			Check if <i>value</i> is present in the bloom filter with size <i>bits</i> number of <i>hash</i> functions.<br />Read BF information document.
			<h3>Return type:</h3>
			bool
			<h3>Return value:</h3>
			0 if value is not present<br />1 if value is MAY BE present
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="BFMEXISTS">

			<h2>BFMEXISTS key bits hash value [value]...</h2>

			<table border="1">
				<tr><td>Command			</td><td>BFMEXISTS</td></tr>
				<tr><td>Available since		</td><td>1.3.1</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>bf.h</td></tr>
			</table>

			<h3>Description:</h3>
			Check if <i>value</i>'s are present in the bloom filter with size <i>bits</i> number of <i>hash</i> functions.<br />Read Bitset information document.
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			array of bools0 if value is not present<br />1 if value is MAY BE present
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="CMSADD">

			<h2>CMSADD / CMSINCR / CMSINCRBY key W_width D_depth integer_size value inc [value inc]...</h2>

			<table border="1">
				<tr><td>Command			</td><td>CMSADD</td></tr>
				<tr><td>Available since		</td><td>1.3.1</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ + WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>cms.h</td></tr>
			</table>

			<h3>Description:</h3>
			Add (insert) <i>value</i> into the count min sketch with size <i>W_width</i> x <i>D_depth</i> and <i>integer_size</i> integers.<br /><i>inc</i> specify how many times you want to add it / how much to increase it.<br />Read CMS information document.
			<h3>Return type:</h3>
			OK
			<h3>Return value:</h3>
			OK
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="CMSRESERVE">

			<h2>CMSRESERVE key key W_width D_depth integer_size</h2>

			<table border="1">
				<tr><td>Command			</td><td>CMSRESERVE</td></tr>
				<tr><td>Available since		</td><td>1.3.1</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ + WRITE</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>cms.h</td></tr>
			</table>

			<h3>Description:</h3>
			Create new, empty count min sketch with size <i>W_width</i> x <i>D_depth</i> and <i>integer_size</i> integers.<br />Read CMS information document.
			<h3>Return type:</h3>
			OK
			<h3>Return value:</h3>
			OK
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="CMSCOUNT">

			<h2>CMSCOUNT key key W_width D_depth integer_size value</h2>

			<table border="1">
				<tr><td>Command			</td><td>CMSCOUNT</td></tr>
				<tr><td>Available since		</td><td>1.3.1</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>cms.h</td></tr>
			</table>

			<h3>Description:</h3>
			Check estimated count of <i>value</i> that may be present into the count min sketch with size <i>W_width</i> x <i>D_depth</i> and <i>integer_size</i> integers.<br />Read CMS information document.
			<h3>Return type:</h3>
			int
			<h3>Return value:</h3>
			estimated count
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="CMSMCOUNT">

			<h2>CMSMCOUNT / CMSQUERY key W_width D_depth integer_size value [value]...</h2>

			<table border="1">
				<tr><td>Command			</td><td>CMSMCOUNT</td></tr>
				<tr><td>Available since		</td><td>1.3.1</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>cms.h</td></tr>
			</table>

			<h3>Description:</h3>
			Check estimated count of <i>value</i> that may be present into the count min sketch with size <i>W_width</i> x <i>D_depth</i> and <i>integer_size</i> integers.<br />Read CMS information document.
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			array of estimated counts
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="MC2GET">

			<h2>MC2GET key subkey</h2>

			<table border="1">
				<tr><td>Command			</td><td>MC2GET</td></tr>
				<tr><td>Available since		</td><td>1.3.7.7</td></tr>
				<tr><td>Data lookup complexity	</td><td>2 * READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>mortoncurve.h</td></tr>
			</table>

			<h3>Description:</h3>
			Get value of the <i>subkey</i> stored in <i>key</i>.
			<h3>Return type:</h3>
			string
			<h3>Return value:</h3>
			value of the subkey
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="MC2MGET">

			<h2>MC2MGET key subkey [subkey]...</h2>

			<table border="1">
				<tr><td>Command			</td><td>MC2MGET</td></tr>
				<tr><td>Available since		</td><td>1.3.7.7</td></tr>
				<tr><td>Data lookup complexity	</td><td>[number of items] * 2 * READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>mortoncurve.h</td></tr>
			</table>

			<h3>Description:</h3>
			Get values of the <i>subkey</i> stored in <i>key</i>.
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			values of the items
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="MC2EXISTS">

			<h2>MC2EXISTS key subkey</h2>

			<table border="1">
				<tr><td>Command			</td><td>MC2EXISTS</td></tr>
				<tr><td>Available since		</td><td>1.3.7.7</td></tr>
				<tr><td>Data lookup complexity	</td><td>2 * READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>mortoncurve.h</td></tr>
			</table>

			<h3>Description:</h3>
			Check if <i>subkey</i> stored in <i>key</i>.
			<h3>Return type:</h3>
			bool
			<h3>Return value:</h3>
			0 if the item do not exists.<br />1 if the item exists.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="MC2SCORE">

			<h2>MC2SCORE key subkey</h2>

			<table border="1">
				<tr><td>Command			</td><td>MC2SCORE</td></tr>
				<tr><td>Available since		</td><td>1.3.7.7</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>mortoncurve.h</td></tr>
			</table>

			<h3>Description:</h3>
			Get score of the <i>subkey</i> stored in <i>key</i>.
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			x and y
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="MC2ADD">

			<h2>MC2ADD subKey x y value [subKey x y value]...</h2>

			<table border="1">
				<tr><td>Command			</td><td>MC2ADD</td></tr>
				<tr><td>Available since		</td><td>1.3.7.7</td></tr>
				<tr><td>Data lookup complexity	</td><td>[number of items] * (READ + 3 * WRITE)</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>mortoncurve.h</td></tr>
			</table>

			<h3>Description:</h3>
			Set <i>subkey</i> with 2D coordinates <i>x</i> and <i>y</i> and <i>value</i> in <i>key</i>.<br />Uses <b>uint32_t</b> for coordinates.
			<h3>Return type:</h3>
			OK
			<h3>Return value:</h3>
			OK
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="MC2REM">

			<h2>MC2REM key subkey [subkey]...</h2>

			<table border="1">
				<tr><td>Command			</td><td>MC2REM</td></tr>
				<tr><td>Available since		</td><td>1.3.7.7</td></tr>
				<tr><td>Data lookup complexity	</td><td>[number of items] * (READ + 2 * WRITE)</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>mortoncurve.h</td></tr>
			</table>

			<h3>Description:</h3>
			Removes <i>subkey</i> stored in <i>key</i>.
			<h3>Return type:</h3>
			bool
			<h3>Return value:</h3>
			Always return 1
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="MC2POINT">

			<h2>MC2POINT key x y number [start]</h2>

			<table border="1">
				<tr><td>Command			</td><td>MC2POINT</td></tr>
				<tr><td>Available since		</td><td>1.3.7.7</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>mortoncurve.h</td></tr>
			</table>

			<h3>Description:</h3>
			Gets all subkeys stored in 'point' with 2D coordinates <i>x</i> and <i>y</i>.<br />Uses <b>uint32_t</b> for coordinates.<br /><i>start</i> specify starting key (for pagination in the similar way as in XNGET).<br />Return up to <i>number</i> of pairs.<br />Returns up to ~32'000 elements.
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			First group of element         - array of key and values.<br />Second group of single element - Last key, if there is second page.
						<h3>Example:</h3>
			<pre><i>Suppose we have a company with two offices in LA and NYC (LA=1, NYC=2).</i><br /><i>Each office have two kind of employees - sales and support (sales=1 and support=2).</i><br /><br />mc2set users 0 1 1 john          <i>adds user_id 0, john,   sales,   LA</i><br />mc2set users 1 1 1 peter         <i>adds user_id 1, peter,  sales,   LA</i><br />mc2set users 2 2 1 jill          <i>adds user_id 2, jill,   support, LA</i><br />mc2set users 3 1 2 robert        <i>adds user_id 3, robert, sales,   NYC</i><br />mc2set users 4 2 2 pola          <i>adds user_id 4, pola,   support, NYC</i><br />mc2set users 5 2 2 pepe          <i>adds user_id 5, pepe,   support, NYC</i><br />mc2point users 2 2 10000         <i>gets all support from LA               (pola, pepe)</i><br /><br />xnget users~ 1000 users~</pre>			
						<h3>MySQL Rosetta:</h3>
			<pre>select key, val from table where x = [x] and y = [y] limit [number]</pre>			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="MC2RANGE">

			<h2>MC2RANGE key x_min x_max y_min y_max number [start]</h2>

			<table border="1">
				<tr><td>Command			</td><td>MC2RANGE</td></tr>
				<tr><td>Available since		</td><td>1.3.7.7</td></tr>
				<tr><td>Data lookup complexity	</td><td>N * READ, were N &isin; { 1 .. 9 }</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>mortoncurve.h</td></tr>
			</table>

			<h3>Description:</h3>
			Gets all subkeys stored in 'rectangle' with 2D coordinates <i>x_min</i> and <i>y_min</i> to <i>x_max</i> and <i>y_max</i>.<br />Uses <b>uint32_t</b> for coordinates.<br /><i>start</i> specify starting key (for pagination in the similar way as in XNGET).<br />Return up to <i>number</i> of pairs.<br />Returns up to ~32'000 elements.<br />Note this command is useful only on very large datasets.
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			First group of element         - array of key and values.<br />Second group of single element - Last key, if there is second page.
						<h3>Example:</h3>
			<pre><i>Suppose we have a company with two offices in LA and NYC (LA=1, NYC=2).</i><br /><i>Each office have two kind of employees - sales and support (sales=1 and support=2).</i><br /><br />mc2set users 0 1 1 john          <i>adds user_id 0, john,   sales,   LA</i><br />mc2set users 1 1 1 peter         <i>adds user_id 1, peter,  sales,   LA</i><br />mc2set users 2 2 1 jill          <i>adds user_id 2, jill,   support, LA</i><br />mc2set users 3 1 2 robert        <i>adds user_id 3, robert, sales,   NYC</i><br />mc2set users 4 2 2 pola          <i>adds user_id 4, pola,   support, NYC</i><br />mc2set users 5 2 2 pepe          <i>adds user_id 5, pepe,   support, NYC</i><br />mc2point users 2 2 10000         <i>gets all support from LA               (pola, pepe)</i><br />mc2range users 2 2 2 2 10000     <i>gets all support from LA               (pola, pepe) - same as previous, but slower.</i><br />mc2range users 2 2 1 2 10000     <i>gets support from LA and NYC           (jill, pola, pepe)</i><br />mc2range users 1 2 2 2 10000     <i>gets sales and support from LA         (robert, pola, pepe)</i><br />mc2range users 1 2 1 2 10000     <i>gets sales and support from LA and NYC (all)</i><br /><br />xnget users~ 1000 users~</pre>			
						<h3>MySQL Rosetta:</h3>
			<pre>select key, val from table where x >= [x_min] and x <= [x_max] and y >= [y_min] and y <= [y_max] limit [number]</pre>			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="MC2RANGENAIVE">

			<h2>MC2RANGENAIVE key x_min x_max y_min y_max number [start]</h2>

			<table border="1">
				<tr><td>Command			</td><td>MC2RANGENAIVE</td></tr>
				<tr><td>Available since		</td><td>1.3.7.7</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>mortoncurve.h</td></tr>
			</table>

			<h3>Description:</h3>
			Naive, non performant version of MC2XNGET. Made for small datasets and for testing.<br />See MC2RANGE for more information.<br />Uses <b>uint32_t</b> for coordinates.<br />Technically the data lookup complexity is single READ, but on large datasets, it might need to read complete dataset.
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			results
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="MC2ENCODE">

			<h2>MC2ENCODE x y</h2>

			<table border="1">
				<tr><td>Command			</td><td>MC2ENCODE</td></tr>
				<tr><td>Available since		</td><td>1.3.7.7</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>n/a</td></tr>
				<tr><td>Module			</td><td>mortoncurve.h</td></tr>
			</table>

			<h3>Description:</h3>
			Encode <i>x</i> and <i>y</i> to morton code hex string.<br />Uses <b>uint32_t</b> for coordinates.
			<h3>Return type:</h3>
			string
			<h3>Return value:</h3>
			morton code hex string
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="MC2DECODE">

			<h2>MC2DECODE hex</h2>

			<table border="1">
				<tr><td>Command			</td><td>MC2DECODE</td></tr>
				<tr><td>Available since		</td><td>1.3.7.7</td></tr>
				<tr><td>Data lookup complexity	</td><td>READ</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>n/a</td></tr>
				<tr><td>Module			</td><td>mortoncurve.h</td></tr>
			</table>

			<h3>Description:</h3>
			Decode <i>morton code hex string</i> to x, y.
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			x and y
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="MURMUR">

			<h2>MURMUR / MURMURHASH64A string [seed=0] [modulo=0]</h2>

			<table border="1">
				<tr><td>Command			</td><td>MURMUR</td></tr>
				<tr><td>Available since		</td><td>1.3.0</td></tr>
				<tr><td>Data lookup complexity	</td><td>n/a</td></tr>
				<tr><td>Redis compatible	</td><td>n/a</td></tr>
				<tr><td>Mutable			</td><td>n/a</td></tr>
				<tr><td>Module			</td><td>murmur.h</td></tr>
			</table>

			<h3>Description:</h3>
			Returns murmur_hash64a from value
			<h3>Return type:</h3>
			string
			<h3>Return value:</h3>
			Returns murmur_hash64a from value with specific seed and specific modulo.<br />e.g. murmur_hash64a(value, seed) % modulo<br />Very useful for debugging.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="INFO">

			<h2>INFO</h2>

			<table border="1">
				<tr><td>Command			</td><td>INFO</td></tr>
				<tr><td>Available since		</td><td>1.0.0</td></tr>
				<tr><td>Data lookup complexity	</td><td>n/a</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>n/a</td></tr>
				<tr><td>Module			</td><td>info.h</td></tr>
			</table>

			<h3>Description:</h3>
			Returns server information.
			<h3>Return type:</h3>
			string
			<h3>Return value:</h3>
			Server information.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="DBSIZE">

			<h2>DBSIZE</h2>

			<table border="1">
				<tr><td>Command			</td><td>DBSIZE</td></tr>
				<tr><td>Available since		</td><td>1.2.18</td></tr>
				<tr><td>Data lookup complexity	</td><td>n/a</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>No</td></tr>
				<tr><td>Module			</td><td>info.h</td></tr>
			</table>

			<h3>Description:</h3>
			Returns number of keys.
			<h3>Return type:</h3>
			string (int)
			<h3>Return value:</h3>
			number of keys
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="DBSIZEMUTABLE">

			<h2>DBSIZEMUTABLE</h2>

			<table border="1">
				<tr><td>Command			</td><td>DBSIZEMUTABLE</td></tr>
				<tr><td>Available since		</td><td>1.2.18</td></tr>
				<tr><td>Data lookup complexity	</td><td>n/a</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>Yes</td></tr>
				<tr><td>Module			</td><td>info.h</td></tr>
			</table>

			<h3>Description:</h3>
			Returns number of mutable keys.
			<h3>Return type:</h3>
			string (int)
			<h3>Return value:</h3>
			number of keys
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="VERSION">

			<h2>VERSION</h2>

			<table border="1">
				<tr><td>Command			</td><td>VERSION</td></tr>
				<tr><td>Available since		</td><td>1.2.16</td></tr>
				<tr><td>Data lookup complexity	</td><td>n/a</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>n/a</td></tr>
				<tr><td>Module			</td><td>info.h</td></tr>
			</table>

			<h3>Description:</h3>
			Returns server version.
			<h3>Return type:</h3>
			string
			<h3>Return value:</h3>
			Server version.
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="MAXKEYSIZE">

			<h2>MAXKEYSIZE</h2>

			<table border="1">
				<tr><td>Command			</td><td>MAXKEYSIZE</td></tr>
				<tr><td>Available since		</td><td>1.2.30</td></tr>
				<tr><td>Data lookup complexity	</td><td>n/a</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>n/a</td></tr>
				<tr><td>Module			</td><td>info.h</td></tr>
			</table>

			<h3>Description:</h3>
			Returns MAX_KEY_SIZE.
			<h3>Return type:</h3>
			int
			<h3>Return value:</h3>
			max key size
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="MAXVALSIZE">

			<h2>MAXVALSIZE</h2>

			<table border="1">
				<tr><td>Command			</td><td>MAXVALSIZE</td></tr>
				<tr><td>Available since		</td><td>1.2.30</td></tr>
				<tr><td>Data lookup complexity	</td><td>n/a</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>n/a</td></tr>
				<tr><td>Module			</td><td>info.h</td></tr>
			</table>

			<h3>Description:</h3>
			Returns MAX_VAL_SIZE.
			<h3>Return type:</h3>
			int
			<h3>Return value:</h3>
			max value size
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="PING">

			<h2>PING</h2>

			<table border="1">
				<tr><td>Command			</td><td>PING</td></tr>
				<tr><td>Available since		</td><td>1.2.16</td></tr>
				<tr><td>Data lookup complexity	</td><td>n/a</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>n/a</td></tr>
				<tr><td>Module			</td><td>info.h</td></tr>
			</table>

			<h3>Description:</h3>
			Returns PONG
			<h3>Return type:</h3>
			string
			<h3>Return value:</h3>
			pong
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="ECHO">

			<h2>ECHO message</h2>

			<table border="1">
				<tr><td>Command			</td><td>ECHO</td></tr>
				<tr><td>Available since		</td><td>1.2.16</td></tr>
				<tr><td>Data lookup complexity	</td><td>n/a</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>n/a</td></tr>
				<tr><td>Module			</td><td>info.h</td></tr>
			</table>

			<h3>Description:</h3>
			Returns <i>message</i>.
			<h3>Return type:</h3>
			string
			<h3>Return value:</h3>
			the message
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="TIME">

			<h2>TIME</h2>

			<table border="1">
				<tr><td>Command			</td><td>TIME</td></tr>
				<tr><td>Available since		</td><td>1.3.7.5</td></tr>
				<tr><td>Data lookup complexity	</td><td>n/a</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>n/a</td></tr>
				<tr><td>Module			</td><td>info.h</td></tr>
			</table>

			<h3>Description:</h3>
			Returns current time as timestamp, redis style.
			<h3>Return type:</h3>
			array
			<h3>Return value:</h3>
			first element - current timestamp. second element current microseconds
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="LISTMAINTAINANCE">

			<h2>LISTMAINTAINANCE</h2>

			<table border="1">
				<tr><td>Command			</td><td>LISTMAINTAINANCE</td></tr>
				<tr><td>Available since		</td><td>1.3.5.3</td></tr>
				<tr><td>Data lookup complexity	</td><td>n/a</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>n/a</td></tr>
				<tr><td>Module			</td><td>reload.h</td></tr>
			</table>

			<h3>Description:</h3>
			Run crontab list maintainance. For example, crontab list maintainance may fsync binlogs.<br />Very useful if crontab list maintainance is disabled.
			<h3>Return type:</h3>
			OK
			<h3>Return value:</h3>
			OK
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="SAVE">

			<h2>SAVE / BGSAVE</h2>

			<table border="1">
				<tr><td>Command			</td><td>SAVE</td></tr>
				<tr><td>Available since		</td><td>1.0.0</td></tr>
				<tr><td>Data lookup complexity	</td><td>n/a</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>n/a</td></tr>
				<tr><td>Module			</td><td>reload.h</td></tr>
			</table>

			<h3>Description:</h3>
			Flushes memtable to the disk (this is no-op on immutable servers).Reloads the disktable(s) from the disk.
			<h3>Return type:</h3>
			OK
			<h3>Return value:</h3>
			OK
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="RELOAD">

			<h2>RELOAD</h2>

			<table border="1">
				<tr><td>Command			</td><td>RELOAD</td></tr>
				<tr><td>Available since		</td><td>1.0.0</td></tr>
				<tr><td>Data lookup complexity	</td><td>n/a</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>n/a</td></tr>
				<tr><td>Module			</td><td>reload.h</td></tr>
			</table>

			<h3>Description:</h3>
			Reloads the disktable(s) from the disk.This command is used when disktable(s) are updated or replaced from an external process.
			<h3>Return type:</h3>
			OK
			<h3>Return value:</h3>
			OK
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="SELECT">

			<h2>SELECT database</h2>

			<table border="1">
				<tr><td>Command			</td><td>SELECT</td></tr>
				<tr><td>Available since		</td><td>1.2.16</td></tr>
				<tr><td>Data lookup complexity	</td><td>n/a</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>n/a</td></tr>
				<tr><td>Module			</td><td>compat.h</td></tr>
			</table>

			<h3>Description:</h3>
			Provided for compatibility
			<h3>Return type:</h3>
			OK
			<h3>Return value:</h3>
			OK
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="RESET">

			<h2>RESET</h2>

			<table border="1">
				<tr><td>Command			</td><td>RESET</td></tr>
				<tr><td>Available since		</td><td>1.2.18</td></tr>
				<tr><td>Data lookup complexity	</td><td>n/a</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>n/a</td></tr>
				<tr><td>Module			</td><td>compat.h</td></tr>
			</table>

			<h3>Description:</h3>
			Provided for compatibility
			<h3>Return type:</h3>
			OK
			<h3>Return value:</h3>
			OK
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="TYPE">

			<h2>TYPE key</h2>

			<table border="1">
				<tr><td>Command			</td><td>TYPE</td></tr>
				<tr><td>Available since		</td><td>1.2.16</td></tr>
				<tr><td>Data lookup complexity	</td><td>n/a</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>n/a</td></tr>
				<tr><td>Module			</td><td>compat.h</td></tr>
			</table>

			<h3>Description:</h3>
			Returns type of given <i>key</i>.<br />For compatibility, always return 'string'
			<h3>Return type:</h3>
			string
			<h3>Return value:</h3>
			Always return 'string'
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="TOUCH">

			<h2>TOUCH key</h2>

			<table border="1">
				<tr><td>Command			</td><td>TOUCH</td></tr>
				<tr><td>Available since		</td><td>1.2.17</td></tr>
				<tr><td>Data lookup complexity	</td><td>n/a</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>n/a</td></tr>
				<tr><td>Module			</td><td>compat.h</td></tr>
			</table>

			<h3>Description:</h3>
			Returns number of touched keys.<br />For compatibility, always return '1'
			<h3>Return type:</h3>
			string
			<h3>Return value:</h3>
			Always return '1'
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="EXIT">

			<h2>EXIT / QUIT</h2>

			<table border="1">
				<tr><td>Command			</td><td>EXIT</td></tr>
				<tr><td>Available since		</td><td>1.0.0</td></tr>
				<tr><td>Data lookup complexity	</td><td>n/a</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>n/a</td></tr>
				<tr><td>Module			</td><td>system.h</td></tr>
			</table>

			<h3>Description:</h3>
			Disconnect from the server.
			<h3>Return type:</h3>
			n/a
			<h3>Return value:</h3>
			n/a
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="SHUTDOWN">

			<h2>SHUTDOWN</h2>

			<table border="1">
				<tr><td>Command			</td><td>SHUTDOWN</td></tr>
				<tr><td>Available since		</td><td>1.0.0</td></tr>
				<tr><td>Data lookup complexity	</td><td>n/a</td></tr>
				<tr><td>Redis compatible	</td><td>Yes</td></tr>
				<tr><td>Mutable			</td><td>n/a</td></tr>
				<tr><td>Module			</td><td>system.h</td></tr>
			</table>

			<h3>Description:</h3>
			Shutdowns the server.<br />SAVE / NOSAVE is not supported yet.
			<h3>Return type:</h3>
			n/a
			<h3>Return value:</h3>
			n/a
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
				<div class="cmd" id="TEST">

			<h2>TEST</h2>

			<table border="1">
				<tr><td>Command			</td><td>TEST</td></tr>
				<tr><td>Available since		</td><td>1.3.5.1</td></tr>
				<tr><td>Data lookup complexity	</td><td>n/a</td></tr>
				<tr><td>Redis compatible	</td><td>No</td></tr>
				<tr><td>Mutable			</td><td>n/a</td></tr>
				<tr><td>Module			</td><td>test.h</td></tr>
			</table>

			<h3>Description:</h3>
			Internal command to do tests during development
			<h3>Return type:</h3>
			n/a
			<h3>Return value:</h3>
			n/a
			
			
			<p class="top"><a href="#top">top</a></p>
		</div>
		


</body>
</html>

